#include "../include/am.ams.service.hpp"
#include <thread>

namespace ams {
	// Database file name
	wchar_t* database = L"test.db";

	// Antimalware service constructor
	AntimalwareService::AntimalwareService(LogTracer& tracer) noexcept:
	Service(tracer, L"AntimalwareService"), UIPipe(nullptr), WDPipe(nullptr),
		tq(nullptr), mts(nullptr), state(true),  rb(32) { }

	// Init Service return non-zero value in current implementation
	DWORD AntimalwareService::Init() noexcept {
		// Open db file for saving him name
		dbfr.Open(database);
		dbfr.CloseFile();
		dbfw.Open(database);
		dbfw.CloseFile();
		std::thread ui_thread(UIPipeThreadFunc, this);
		ui_thread.detach();
		std::thread wd_thread(WDPipeThreadFunc, this);
		wd_thread.detach();
		return DWORD(0);
	}

	// Main Service Function
	void AntimalwareService::DoWork() noexcept {
		Sleep(10000);
	}

	// Stop Service return non-zero value in current implementation
	DWORD AntimalwareService::DoStop() noexcept {
		state = false;
		mts->Shutdown();
		Sleep(50);
		delete UIPipe;
		delete WDPipe;
		delete tq;
		delete mts;
		return DWORD(0);
	}

	// Choose action for doing
	void AntimalwareService::ChooseAction(ipc::MessageHolder& msg,
	  trace::LogTracer& tracer) noexcept {
		using namespace ipc;
		ControlMessage cMsg;
		TasksContainer tCont;
		ScanningStat scStat;

		// Choose action
		switch (msg.mType) {
		case MessageType::CtrlMessage:
			cMsg = msg.Unpack<ControlMessage>();
			ControlService(cMsg, tracer);
			break;
		case MessageType::Task:
			tCont = msg.Unpack<TasksContainer>();
			TaskHandler(tCont, tracer);
			break;
		case MessageType::ScanningStatus:
			scStat = msg.Unpack<ScanningStat>();
			ScanStatusHandler(scStat, tracer);
			break;
		default:
			std::this_thread::yield();
			break;
		}
	}

	// Set service in received state
	void AntimalwareService::ControlService(ipc::ControlMessage& ctrlMsg,
	  trace::LogTracer& tracer) noexcept {
		// Info trace
		tracer.Trace(trace::TraceLevel::Info)
			<< TEXT("UIServer get msg from UIClient: ") << ctrlMsg << TEXT("\n\n");
		switch (ctrlMsg) {
		case ipc::ControlMessage::Start:
			Start();
			break;
		case ipc::ControlMessage::Stop:
			Stop();
			break;
		case ipc::ControlMessage::Shutdown:
			Shutdown();
			break;
		}

	}

	// Pass tasks container to queue of tasks
	void AntimalwareService::TaskHandler(ipc::TasksContainer& tCon,
	  trace::LogTracer& tracer) noexcept {
		tq->PassUnformatedStr(tCon.unformString);
		
		// TODO: mts set tCon.dAction

	}

	// Scanning status handler
	void AntimalwareService::ScanStatusHandler(ipc::ScanningStat& scStat,
	  trace::LogTracer& tracer) noexcept {
		switch (scStat) {
		case ipc::ScanningStat::Request:
			// TODO: return current state to UI Client
			break;
		case ipc::ScanningStat::Active:
			// TODO: resume scanning
			break;
		case ipc::ScanningStat::Pause:
			// TODO: pause scanning
			break;
		case ipc::ScanningStat::Ended:
			// TODO: stop scanning
			break;
		}
	}

	// Simple authorization protocol, reading message from UIPipe
	void AntimalwareService::UIPipeThreadFunc(AntimalwareService* ptrAMS) noexcept {
		using namespace ipc;
		using namespace auth;
		// Init UI
		LogTracer tracer;
		ptrAMS->UIPipe = new ServerPipe(TEXT("UIPipe"), tracer);
		ptrAMS->tq = new scan::TaskQueue(*ptrAMS->UIPipe);
		ptrAMS->mts = new scan::MultiThreadScanner(ptrAMS->tq, &ptrAMS->dbfr, &ptrAMS->rb, ptrAMS->UIPipe);
		// Main loop for UI pipe
		AuthStat status;
		MessageHolder msg;
		while (ptrAMS->state) {
			// Wait message from UI and try read it
			ptrAMS->UIPipe->WaitIncomingMsg();
			try {
				msg = ptrAMS->UIPipe->ReadMsg();
				status = AuthServer(*ptrAMS->UIPipe);
			}
			// If errors happened
			catch (std::exception& ex) {
				// Debug trace
				std::string tmpStr(ex.what());
				tracer.Trace(trace::TraceLevel::Error)
					<< TEXT("Fatal error in ams::UIPipeThreadFunc: ")
					<< std::wstring(tmpStr.begin(), tmpStr.end()).c_str()
					<< TEXT("\n");

				// Shutdown service
				status = AuthStat::Disconnected;
				ptrAMS->Shutdown();
			}
			if (status == AuthStat::Connected) {
				ptrAMS->ChooseAction(msg, tracer);
			}
		}
	}

	// Simple authorization protocol, reading message from WDPipe
	void AntimalwareService::WDPipeThreadFunc(AntimalwareService* ptrAMS) noexcept {

		// TODO: Do check messages from watch dog

	}

	// Constructor
	AntimalwareServiceFactory::AntimalwareServiceFactory(std::shared_ptr<LogTracer>& _tracer) noexcept:
	tracer(std::move(_tracer)) { }

	// Create AntimalwareService from Factory Class
	std::unique_ptr<Service> AntimalwareServiceFactory::Create() {
		return std::make_unique<AntimalwareService>(*tracer);
	}

}
