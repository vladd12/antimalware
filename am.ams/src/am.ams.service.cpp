#include "../include/am.ams.service.hpp"
#include "am.auth.protocol.hpp"
#include <thread>

namespace ams {
	/* --- Function prototypes --- */
	// Simple authorization protocol, reading message from UIPipe
	void UIPipeThreadFunc(AntimalwareService*) noexcept;

	// Constructor
	AntimalwareService::AntimalwareService(LogTracer& tracer) noexcept:
		Service(tracer, L"AntimalwareService") { }

	// Init Service return non-zero value in current implementation
	DWORD AntimalwareService::Init() noexcept {
		std::thread UIPipeThread(UIPipeThreadFunc, this);
		UIPipeThread.detach();
		return DWORD(0);
	}

	// Main Service Function
	void AntimalwareService::DoWork() noexcept {
		Sleep(10000);
	}

	// Stop Service return non-zero value in current implementation
	DWORD AntimalwareService::DoStop() noexcept {
		return DWORD(0);
	}

	// Simple authorization protocol, reading message from UIPipe
	void UIPipeThreadFunc(AntimalwareService* ptrAMS) noexcept {
		using ipc::ServerPipe;
		using namespace auth;
		LogTracer tracer("E:\\Test.txt");
		ServerPipe UIPipe(TEXT("UIPipe"), tracer);
		while (true) {
			UIPipe.WaitIncomingMsg();
			MsgType command = UIPipe.ReadMsg<MsgType>();
			AuthStatus stat = AuthServer(UIPipe);
			if (stat == AuthStatus::Connected) {
				// Info trace
				tracer.Trace(trace::TraceLevel::Info)
					<< TEXT("UIServer get msg from UIClient: ") << command << TEXT("\n\n");
				switch (command) {
				case MsgType::Start:
					ptrAMS->Start();
					break;
				case MsgType::Stop:
					ptrAMS->Stop();
					break;
				case MsgType::Shutdown:
					ptrAMS->Shutdown();
					break;
				}
			}
		}
	}

	// Constructor
	AntimalwareServiceFactory::AntimalwareServiceFactory(std::shared_ptr<LogTracer>& _tracer) noexcept:
		tracer(std::move(_tracer)) { }

	// Create AntimalwareService from Factory Class
	std::unique_ptr<Service> AntimalwareServiceFactory::Create() {
		return std::make_unique<AntimalwareService>(*tracer);
	}
}
