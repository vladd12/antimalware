#include "../include/am.ams.service.hpp"
#include <thread>

namespace ams {
	/* ------ Function prototypes ------ */
	// Set service in received state
	static void ControlService(AntimalwareService* ptrAMS, ipc::ControlMessage& ctrlMsg) noexcept;
	// Pass tasks container to queue of tasks
	static void TaskHandler(db::DBFileReader& dbfr, HANDLE evSync,
		ipc::ServerPipe& connection, ipc::TasksContainer& tCon) noexcept;
	/* --- End of function prototypes --- */

	// Database file name
	wchar_t* database = L"test.db";

	// Antimalware service constructor
	AntimalwareService::AntimalwareService(LogTracer& _tracer) noexcept:
	Service(_tracer, L"AntimalwareService"), SCM(), state(true), evSync(NULL) { }

	// Init Service return non-zero value in current implementation
	DWORD AntimalwareService::Init() noexcept {
		// Open db file for saving him name
		evSync = CreateSyncEvent("Global\\ServiceSyncEvent");
		dbfr.Open(database);
		dbfr.CloseFile();
		dbfw.Open(database);
		dbfw.CloseFile();
		//std::thread wd_thread(WDPipeThreadFunc, this);
		//wd_thread.detach();
		return DWORD(0);
	}

	// Stop Service return non-zero value in current implementation
	DWORD AntimalwareService::DoStop() noexcept {
		if (evSync != NULL) CloseHandle(evSync);
		state = false;
		Sleep(500);
		return DWORD(0);
	}

	// Listen connections from clients
	void AntimalwareService::DoWork() noexcept {
		auto connection = new ipc::ServerPipe();
		*connection = SCM.GetConnection();
		std::thread executor(ClientThread, connection, this);
		executor.detach();
	}

	// Client requests executor thread function
	void AntimalwareService::ClientThread(
		ipc::ServerPipe* connection,
		AntimalwareService* ptrAMS) noexcept {
		using namespace ipc;
		// For choosing action
		ControlMessage cMsg;
		TasksContainer tCont;
		// Wait connection from client
		if (connection->WaitConnection()) {
			bool workState = true;
			while (workState) {
				auto msg = connection->Read();
				if (msg.mType != MessageType::None) {
					// Choose action
					switch (msg.mType) {
					case MessageType::CtrlMessage:
						cMsg = msg.Unpack<ControlMessage>();
						ControlService(ptrAMS, cMsg);
						break;
					case MessageType::Task:
						tCont = msg.Unpack<TasksContainer>();
						TaskHandler(ptrAMS->dbfr, ptrAMS->evSync, *connection, tCont);
						break;
					default:
						std::this_thread::yield();
						break;
					}
				}
				else workState = false;
			}
			connection->Close();
			delete connection;
		}
	}

	// Reading message from WDPipe
	void AntimalwareService::WDPipeThreadFunc(AntimalwareService* ptrAMS) noexcept {
		// TODO: Do check messages from watch dog
	}

	// Set service in received state
	void ControlService(AntimalwareService* ptrAMS, ipc::ControlMessage& ctrlMsg) noexcept {
		switch (ctrlMsg) {
		case ipc::ControlMessage::Start:
			// Start();
			break;
		case ipc::ControlMessage::Stop:
			ptrAMS->Shutdown();
			break;
		case ipc::ControlMessage::Shutdown:
			ptrAMS->Shutdown();
			break;
		}

	}

	// Pass tasks container to queue of tasks
	void TaskHandler(db::DBFileReader& dbfr, HANDLE evSync,
	  ipc::ServerPipe& connection, ipc::TasksContainer& tCon) noexcept {
		// For scanning
		scan::TaskQueue tq(connection, evSync);
		tq.PassUnformatedStr(tCon.unformString);
		scan::Scanner scanner(tq, dbfr, tCon.dAction, evSync, connection);
		SetEvent(evSync);

		// Send end of scanning status
		ipc::MessageHolder end(ipc::ScanningStat::EndedSimple);
		end.mType = ipc::MessageType::ScanningStatus;
		connection.Send(end);
		dbfr.CloseFile();
	}

	// Create event for synchronization
	HANDLE AntimalwareService::CreateSyncEvent(const char* evName) noexcept {
		// Creating Security Descriptor for pipe event
		SECURITY_DESCRIPTOR sd = { 0 };
		DWORD fState = InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
		if (fState == NULL) {
			tracer.Trace(trace::TraceLevel::Error) <<
				TEXT("Failed creating of security descriptor: ")
				<< GetLastError() << TEXT('\n');
			return NULL;
		}
		fState = SetSecurityDescriptorDacl(&sd, TRUE, NULL, FALSE);
		if (fState == NULL) {
			tracer.Trace(trace::TraceLevel::Error) <<
				TEXT("Failed creating of security descriptor: ")
				<< GetLastError() << TEXT('\n');
			return NULL;
		}

		// Creating Security Attributes for pipe event
		SECURITY_ATTRIBUTES sa = { 0 };
		sa.nLength = sizeof(sa);
		sa.bInheritHandle = FALSE;
		sa.lpSecurityDescriptor = &sd;

		// Creating pipe event and get handle of it
		HANDLE evHandle = CreateEventA(&sa, TRUE, TRUE, evName);
		//HANDLE evHandle = CreateEventA(NULL, TRUE, TRUE, evName);
		if (evHandle == NULL || evHandle == (HANDLE)ERROR_INVALID_HANDLE ||
		  evHandle == INVALID_HANDLE_VALUE) {
			tracer.Trace(trace::TraceLevel::Error) <<
				TEXT("Failed creating of pipe event: ")
				<< GetLastError() << TEXT('\n');
		}
		return evHandle;
	}

	// Constructor
	AntimalwareServiceFactory::AntimalwareServiceFactory(std::shared_ptr<LogTracer>& _tracer) noexcept:
	tracer(std::move(_tracer)) { }

	// Create AntimalwareService from Factory Class
	std::unique_ptr<Service> AntimalwareServiceFactory::Create() {
		return std::make_unique<AntimalwareService>(*tracer);
	}

}
