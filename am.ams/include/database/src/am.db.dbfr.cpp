#include "../am.db.dbfile.hpp"

namespace db {
	// Opening file
	bool DBFileReader::Open(PCWSTR filePath) {
		std::size_t dbSigLength = strnlen_s(DBSignature, UINT16_MAX);
		if (filePath == nullptr) return false;
		else if (IsFileExistW(filePath)) {
			hFile.open(filePath, std::ios::in | std::ios::out | std::ios::binary);
			if (!IsOpen()) return false;
			// Check signature
			char* sign = new char[dbSigLength];
			hFile.read(sign, dbSigLength);
			// If don't accepted
			if (memcmp(sign, DBSignature, dbSigLength)) {
				delete[] sign;
				CloseFile();
				return false;
			}
			// Else read record count
			else {
				delete[] sign;
				hFile.read(reinterpret_cast<char*>(&RecordCount), sizeof(RecordCount));
				return true;
			}
		}
		else return false;
	}

	// DBFileReader constructor for wide string
	DBFileReader::DBFileReader(PCWSTR filePath) noexcept(false) : DBFile() {
		Open(filePath);
	}

	// DBFileReader constructor for ASCII string
	DBFileReader::DBFileReader(PCSTR filePath) noexcept(false) : DBFile() {
		const std::size_t cSize = strlen(filePath) + 1;
		std::size_t retVal;
		PWSTR wFilePath = new wchar_t[cSize];
		mbstowcs_s(&retVal, wFilePath, cSize, filePath, cSize - 1);
		if (retVal == cSize) {
			Open(wFilePath);
			delete[] wFilePath;
		}
		else {
			delete[] wFilePath;
			throw std::runtime_error("String coverting error");
		}
	}

	// Read record from database
	bool DBFileReader::ReadNextRecord(Record* record) {
		std::size_t sigSize = strnlen_s(DBSignature, 255);
		bool flag1(hFile.eof()), flag2(hFile.bad());
		if (record == nullptr || !IsOpen() || flag1 || flag2) return false;
		hFile.read(reinterpret_cast<char*>(&record->NameLength), sizeof(uint8_t));               // Name length
		if (record->NameLength == 0) return false;                                               // Check length
		record->AllocName(record->NameLength);                                                   // Alloc momory for name string
		hFile.read(record->Name, record->NameLength + 1);                                        // Name
		hFile.read(reinterpret_cast<char*>(&record->Signature.FirstBytes), 8);                   // First 8 bytes of signature
		hFile.read(reinterpret_cast<char*>(&record->Signature.Length), sizeof(uint32_t));        // Signature length
		hFile.read(reinterpret_cast<char*>(&record->Signature.Range.Start), sizeof(uint32_t));   // Signature offset start
		hFile.read(reinterpret_cast<char*>(&record->Signature.Range.End), sizeof(uint32_t));     // Signature offset end
		hFile.read(reinterpret_cast<char*>(&record->Signature.Hash.hash), 8 * sizeof(uint32_t)); // Hash value of signature
		return true;
	}

	// Set file reader to begin of DB file
	void DBFileReader::SetToStart() {
		hFile.seekg(strnlen_s(DBSignature, UINT16_MAX) + sizeof(RecordCount), std::ios::beg);
	}

}
