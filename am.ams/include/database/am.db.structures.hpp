#ifndef AM_DB_STRUCTURES_H
#define AM_DB_STRUCTURES_H

#include <cstdint>
#include <cstdlib>
#include <Windows.h>
#include "../hash/am.hash.sha256.hpp"

namespace db {
	// Offset of signature's location in file
	class SignatureRange {
	public:
		uint32_t Start;
		uint32_t End;

		// Constructor
		SignatureRange() noexcept:
			Start(0), End(0) { }

		// Constructor
		SignatureRange(uint32_t start, uint32_t end)
			noexcept : Start(start), End(end) { }

	}; // Size: 8 bytes

	// Signature class
	class Signature {
	public:
		uint8_t FirstBytes[8];   // First 8 bytes of signature
		uint32_t Length;         // Length of signature
		SignatureRange Range;  // Offset of signature
		hash::SHA256Hash Hash;   // Hash value of signature

		// Constructor
		Signature() noexcept: FirstBytes { 0 },
			Length(0), Range(), Hash() { }

	}; // Size: 52 bytes

	// Record in DB structure
	class Record {
	public:
		char* Name;				 // Signature name
		std::size_t NameLength;  // Length of signature name
		Signature Signature;     // Signature object

		// Constructor
		Record() noexcept: Name(nullptr),
			NameLength(0), Signature() { }

		// Copying constructor
		Record(const Record& rhs) noexcept: Name(nullptr) {
			AllocName(rhs.NameLength);
			CopyName(rhs.Name);
			Signature = rhs.Signature;
		}

		// Destructor
		~Record() noexcept {
			if (Name != nullptr) delete[] Name;
		}

		// Alloc memory for C-string with signature's name 
		void AllocName(std::size_t nameLen) noexcept {
			if (Name == nullptr) {
				NameLength = nameLen;
				Name = new char[NameLength + 1];
				// Fill string by zeros
				memset(Name, NULL, NameLength + 1);
			}
		}

		// Copy data from string
		void CopyName(const char* src) {
			memcpy_s(Name, NameLength + 1, src, strnlen_s(src, 256) + 1);
		}

	};

	// Batch of records from DB
	class RecordBatch {
	private:
		Record* _ptrRecords;
		uint16_t _batchSize;

	public:
		// Delete default constructor
		explicit RecordBatch() noexcept = delete;

		// Declare constructor with params
		explicit RecordBatch(uint16_t batchSize) noexcept(false):
		  _ptrRecords(nullptr), _batchSize(batchSize) {
			_ptrRecords = new Record[_batchSize];
		}

		// Destructor
		~RecordBatch() noexcept(false) {
			if (_ptrRecords != nullptr) delete[] _ptrRecords;
		}

		// Read records from DB file to batch of records
		// Return false if batch is not fully filled, else return true
		bool ReadRecords(DBFileReader& dbfr) {
			std::size_t i;
			for (i = 0; i < _batchSize; i++) {
				if (!dbfr.ReadNextRecord(&_ptrRecords[i])) {
					break;
				}
			}
			return (i == _batchSize);
		}

	};

}

#endif // AM_DB_STRUCTURES_H
