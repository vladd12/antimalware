#ifndef AM_DB_DBFILE_H
#define AM_DB_DBFILE_H

#include <fstream>
#include <iostream>
#include "am.db.structures.hpp"

namespace database {
	// Check existing file (ASCII)
	bool IsFileExistA(LPCSTR FileName) {
		return GetFileAttributesA(FileName) != INVALID_FILE_ATTRIBUTES;
	}

	// Check existing file (Unicode)
	bool IsFileExistW(LPCWSTR FileName) {
		return GetFileAttributesW(FileName) != INVALID_FILE_ATTRIBUTES;
	}

// Define unicode functions
#ifdef UNICODE
#define IsFileExist IsFileExistW
#else
#define IsFileExist IsFileExistA
#endif

	// Database of signatures class
	class DBFile {
	protected:
		std::fstream hFile;  // File stream
		uint32_t RecordCount;   // Num of records in database
		const char* DBSignature;  // DB file signature

	public:
		// Constructor
		DBFile() noexcept: RecordCount(0),
			DBSignature("ABOBA_AM_DB") { }

		// Virtual
		virtual bool Open(PCTSTR filePath) = 0;

		// Checking state of file stream
		virtual bool IsOpen() {
			return hFile.is_open();
		}

		// Closing file stream
		virtual void CloseFile() {
			if (IsOpen()) hFile.close();
		}

		// Getting count of records in database
		virtual uint32_t GetRecordCount() {
			return RecordCount;
		}

	};

	// Class for writing records in database file
	class DBFileWriter: public DBFile {
	public:
		// Constructor
		DBFileWriter() noexcept: DBFile() { }

		// Opening file
		bool Open(PCTSTR filePath) {
			std::size_t dbSigLength = strnlen_s(DBSignature, UINT16_MAX);
			if (filePath == nullptr) return false;
			// If file don't exisiting create it with DBFile signature
			else if (!IsFileExist(filePath)) {
				hFile.open(filePath, std::ios::out | std::ios::binary);
				if (!IsOpen() || !hFile) return false;
				// Writing signature of database file
				hFile.write(DBSignature, dbSigLength);
				// Writing count of records in database file
				hFile.write(reinterpret_cast<char*>(&RecordCount), sizeof(RecordCount));
			}
			// Else open it and check file signature
			else {
				hFile.open(filePath, std::ios::in | std::ios::out | std::ios::binary);
				if (!IsOpen() || !hFile) return false;
				// Check signature
				char* sign = new char[dbSigLength];
				hFile.read(sign, dbSigLength);
				// If don't accepted
				if (memcmp(sign, DBSignature, dbSigLength)) {
					delete[] sign;
					CloseFile();
					return false;
				}
				// Else read record count
				else {
					delete[] sign;
					hFile.read(reinterpret_cast<char*>(&RecordCount), sizeof(RecordCount));
				}
			}
			return true;
		}

		// Add record in database file
		bool AddRecord(Record* record) {
			if (record == nullptr || !IsOpen()) return false;
			// Go to end of file
			hFile.seekp(0, std::ios::end);
			// Write record in database file
			hFile.write(reinterpret_cast<char*>(&record->NameLength), sizeof(std::size_t));                 // Name length
			hFile.write(record->Name, record->NameLength);                                                  // Name
			hFile.write(reinterpret_cast<char*>(&record->Signature.FirstBytes), 8);                         // First 8 bytes of signature
			hFile.write(reinterpret_cast<char*>(&record->Signature.Length), sizeof(uint32_t));              // Signature length
			hFile.write(reinterpret_cast<char*>(&record->Signature.Offset.StartOffset), sizeof(uint32_t));  // Signature offset start
			hFile.write(reinterpret_cast<char*>(&record->Signature.Offset.EndOffset), sizeof(uint32_t));    // Signature offset end
			hFile.write(reinterpret_cast<char*>(&record->Signature.Hash.hash), 8 * sizeof(uint32_t));       // Hash value of signature
			hFile.seekp(3, std::ios::beg);
			RecordCount++;  // Increase record counter
			hFile.write(reinterpret_cast<char*>(&RecordCount), sizeof(DWORD));
			return true;
		}

	};

	// Class for reading records from database file
	class DBFileReader: public DBFile {
	public:
		// Constructor
		DBFileReader() noexcept: DBFile() { }

		// Opening file
		bool Open(PCTSTR filePath) {
			std::size_t dbSigLength = strnlen_s(DBSignature, UINT16_MAX);
			if (filePath == nullptr) return false;
			else if (IsFileExist(filePath)) {
				hFile.open(filePath, std::ios::in | std::ios::out | std::ios::binary);
				if (!IsOpen()) return false;
				// Check signature
				char* sign = new char[dbSigLength];
				hFile.read(sign, dbSigLength);
				// If don't accepted
				if (memcmp(sign, DBSignature, dbSigLength)) {
					delete[] sign;
					CloseFile();
					return false;
				}
				// Else read record count
				else {
					delete[] sign;
					hFile.read(reinterpret_cast<char*>(&RecordCount), sizeof(RecordCount));
					return true;
				}
			}
			else return false;
		}

		// Read record from database
		bool ReadNextRecord(Record* record) {
			if (record == nullptr || !IsOpen() || hFile.eof() || hFile.bad()) return false;
			hFile.read(reinterpret_cast<char*>(&record->NameLength), sizeof(std::size_t));                 // Name length
			record->AllocName(record->NameLength);                                                         // Alloc momory for name string
			hFile.read(record->Name, record->NameLength);                                                  // Name
			hFile.read(reinterpret_cast<char*>(&record->Signature.FirstBytes), 8);                         // First 8 bytes of signature
			hFile.read(reinterpret_cast<char*>(&record->Signature.Length), sizeof(uint32_t));              // Signature length
			hFile.read(reinterpret_cast<char*>(&record->Signature.Offset.StartOffset), sizeof(uint32_t));  // Signature offset start
			hFile.read(reinterpret_cast<char*>(&record->Signature.Offset.EndOffset), sizeof(uint32_t));    // Signature offset end
			hFile.read(reinterpret_cast<char*>(&record->Signature.Hash.hash), 8 * sizeof(uint32_t));       // Hash value of signature
			return true;
		}

	};

}

#endif // AM_DB_DBFILE_H
