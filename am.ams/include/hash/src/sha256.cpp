#include "../sha256.hpp"
#include <cstring>

namespace hash {
	// Main algorithm function
	SHA256Hash GetSHA256(uint8_t* msg, const std::size_t size) {
		// Declare the K constant
		const uint32_t K[64] = {
			0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
			0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
			0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
			0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
			0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
			0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
			0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
			0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
			0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
			0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
			0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
			0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
			0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
			0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
			0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
			0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
		};

		/* --- Variables --- */
		//
		// Message schedule
		uint32_t W[64];
		// Hash value
		SHA256Hash _hashObject;
		// Working variables
		uint32_t a, b, c, d, e, f, g, h;
		// Temp variables
		uint32_t temp1, temp2;
		// For loop to iterate through the message block 
		uint32_t i;
		// How many bytes are remains until the end of data
		std::size_t remained = size;
		// The current message block
		MessageBlock msgBlock;
		// The state of the program
		HashStatus state = HashStatus::Read;
		// Check for big or little endian system
		bool isBigEndFlag = IsBigEndian();

		// Main loop of algorithm
		while (state != HashStatus::Finish) {
			FillMessageBlock(msg, msgBlock, state, remained, size);
			for (i = 0; i < 16; i++) {
				// If our system is big-endian we dont need to do any conversion
				if (isBigEndFlag) W[i] = msgBlock.dwords[i];
				else {
					// Add the current message block to our messag schedule
					// Convert to big endian first
					W[i] = ByteSwap32(msgBlock.dwords[i]);
				}
			}

			// Step 1
			for (i = 16; i < 64; i++) {
				W[i] = sig1(W[i - 2]) + W[i - 7] + sig0(W[i - 15]) + W[i - 16];
			}

			// Step 2. Initalize a-h variables
			a = _hashObject.hash[0];
			b = _hashObject.hash[1];
			c = _hashObject.hash[2];
			d = _hashObject.hash[3];
			e = _hashObject.hash[4];
			f = _hashObject.hash[5];
			g = _hashObject.hash[6];
			h = _hashObject.hash[7];

			// Step 3
			for (i = 0; i < 64; i++) {
				// Creating new variables
				temp1 = h + Sigma1(e) + Choose(e, f, g) + K[i] + W[i];
				temp2 = Sigma0(a) + Majority(a, b, c);
				h = g;
				g = f;
				f = e;
				e = d + temp1;
				d = c;
				c = b;
				b = a;
				a = temp1 + temp2;
			}

			// Step 4
			_hashObject.hash[0] = a + _hashObject.hash[0];
			_hashObject.hash[1] = b + _hashObject.hash[1];
			_hashObject.hash[2] = c + _hashObject.hash[2];
			_hashObject.hash[3] = d + _hashObject.hash[3];
			_hashObject.hash[4] = e + _hashObject.hash[4];
			_hashObject.hash[5] = f + _hashObject.hash[5];
			_hashObject.hash[6] = g + _hashObject.hash[6];
			_hashObject.hash[7] = h + _hashObject.hash[7];
		}  // End of main algorithm loop

		return _hashObject;
	}

	// This function is used to handle algorithm state
	void FillMessageBlock(uint8_t* msg, MessageBlock& msgBlock, HashStatus& state, std::size_t& remained, const std::size_t& size) {
		// 512 bits is size of one block data
		const std::size_t blockSize = 64;

		// Check if we are need another block full of padding
		if (state == HashStatus::Padding0 || state == HashStatus::Padding1) {
			// Set the first 56 bytes to all zero bits
			for (std::size_t i = 0; i < 7; i++) {
				msgBlock.qwords[i] = 0x00;
			}

			// Set the last 64 bits to an integer (should be big endian)
			msgBlock.qwords[7] = ByteSwap64(size * 8);
			// If state is Padding1, set the first bit of msgBlock to 1
			if (state == HashStatus::Padding1) {
				msgBlock.bytes[0] = 0x80;
			}
			// Algorithm is finished
			state = HashStatus::Finish;
		}

		// Check remained hashing data
		if (remained == 0) {
			if (state == HashStatus::Read) {
				state = HashStatus::Padding1;
			}
			return;
		}
		// If remaining bytes in range [1 - 63]
		else if (remained < blockSize) {
			memcpy_s(&msgBlock.bytes, remained, msg, remained);
			msg += remained;
			// In range [1 - 55]
			if (remained < 56) {
				FillOneBitAndZeros(msgBlock, remained, 56);
				// Store the length of the data in bits as uint64_t (Should be big endian)
				msgBlock.qwords[7] = ByteSwap64(size * 8);
				// Algorithm is finished
				state = HashStatus::Finish;
			}
			// In range [56 - 63]
			else {
				FillOneBitAndZeros(msgBlock, remained, blockSize);
				state = HashStatus::Padding0;
			}
			remained = 0;
		}
		// If remaining bits is 512 (64 bytes)
		else if (remained == blockSize) {
			memcpy_s(&msgBlock.bytes, remained, msg, remained);
			msg += remained;
			state = HashStatus::Padding1;
			remained = 0;
		}
		// If remaining bits is more then 512
		else {
			memcpy_s(&msgBlock.bytes, blockSize, msg, blockSize);
			msg += blockSize;
			remained -= blockSize;
		}
	}

	// This function is used to fill message block
	// in the specified range by one bit and zeros
	void FillOneBitAndZeros(MessageBlock& msgBlock, const std::size_t& start, const std::size_t end) {
		// 0x80 = 10000000
		// Add the one bit, as per the standard before padding with zeros
		msgBlock.bytes[start] = 0x80;
		// Add 0 bits in msgBlock[start + 1 : end]
		for (std::size_t i = start + 1; i < end; i++) {
			msgBlock.bytes[i] = 0x00;
		}
	}







}
