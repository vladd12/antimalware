#include "../hash_bitops.hpp"
#include "../hash_structs.hpp"

namespace hash {
	// Converting little endian to big endian for uint32_t
	uint32_t ByteSwap32(uint32_t x) {
		return (((x) >> 24) | (((x)& 0x00FF0000) >> 8) | (((x)& 0x0000FF00) << 8) | ((x) << 24));
	}

	// Converting little endian to big endian for uint64_t
	uint64_t ByteSwap64(uint64_t x) {
		return ((((x) >> 56) & 0x00000000000000FF) | (((x) >> 40) & 0x000000000000FF00) |
			(((x) >> 24) & 0x0000000000FF0000) | (((x) >> 8) & 0x00000000FF000000) |
			(((x) << 8) & 0x000000FF00000000) | (((x) << 24) & 0x0000FF0000000000) |
			(((x) << 40) & 0x00FF000000000000) | (((x) << 56) & 0xFF00000000000000));
	}

	// Rotate bits right
	uint32_t rotr(uint32_t x, uint16_t n) {
		return (x >> n) | (x << (32 - n));
	}

	// Shift bits right
	uint32_t shr(uint32_t x, uint16_t n) {
		return (x >> n);
	}

	// Lower sigma0 func
	uint32_t sig0(uint32_t x) {
		return (rotr(x, 7) ^ rotr(x, 18) ^ shr(x, 3));
	}

	// Lower sigma1 func
	uint32_t sig1(uint32_t x) {
		return (rotr(x, 17) ^ rotr(x, 19) ^ shr(x, 10));
	}

	// Sigma0 definition func
	uint32_t Sigma0(uint32_t x) {
		return (rotr(x, 2) ^ rotr(x, 13) ^ rotr(x, 22));
	}

	// Sigma1 definition func
	uint32_t Sigma1(uint32_t x) {
		return (rotr(x, 6) ^ rotr(x, 11) ^ rotr(x, 25));
	}

	// Choose
	uint32_t Choose(uint32_t x, uint32_t y, uint32_t z) {
		return ((x & y) ^ (~(x)&z));
	}

	// Majority decision
	uint32_t Majority(uint32_t x, uint32_t y, uint32_t z) {
		return ((x & y) ^ (x & z) ^ (y & z));
	}

	// Check system endian
	bool IsBigEndian() {
		int num = 1;
		// Little-Endian system detected
		if (*reinterpret_cast<char*>(&num) == 1) return false;
		// Big-Endian system detected
		else return true;
	}

	// Constructor. Initial hash values
	SHA256Hash::SHA256Hash() : hash
	{
		0x6a09e667,
		0xbb67ae85,
		0x3c6ef372,
		0xa54ff53a,
		0x510e527f,
		0x9b05688c,
		0x1f83d9ab,
		0x5be0cd19
	}
	{}

	// Comparison operator overloading
	bool hash::operator==(const SHA256Hash& lhs, const SHA256Hash& rhs) {
		bool flag = true;
		for (std::size_t i = 0; i < 8; i++) {
			if (lhs.hash[0] != rhs.hash[0]) {
				flag = false;
				break;
			}
		}
		return flag;
	}

}
