#ifndef AM_SCAN_SCANNER_H
#define AM_SCAN_SCANNER_H

#include <atomic>
#include <deque>
#include <mutex>
#include <queue>
#include <string>
#include <thread>
#include <vector>
#include "am.ipc.scm.hpp"
#include "am.scan.peops.hpp"
#include "am.scan.kmp.hpp"
#include "../database/am.db.recbatch.hpp"
#include "../hash/am.hash.sha256.hpp"

namespace scan {
	// Class for organisation queue of tasks
	class TaskQueue {
	private:
		std::queue<std::string> tasks;
		ipc::ServerPipe& pipe;
		HANDLE evSync;
		bool isFirst;

		// Split string to substrings
		std::vector<std::string> SplitString(const std::string& str, char delimeter) noexcept;

		// Scan path function
		void ScanPath(std::string& path) noexcept;

		// Check is file executable
		void CheckFile(std::string& file) noexcept;

		// Sending status about non executable file
		void SendFileStatus(std::string& file) noexcept;

		// ttt
		bool CheckSyncState() noexcept;

	public:
		// Delete default constructor
		explicit TaskQueue() noexcept = delete;

		// Constructor with params
		explicit TaskQueue(ipc::ServerPipe& _pipe, HANDLE _evSync) noexcept;

		// Parse unformated string to getting 
		// executable files in received paths
		void PassUnformatedStr(std::string unformatted);
		
		// Return size of queue of tasks
		std::size_t GetSize() noexcept;

		// Return false if queue is empty, else return true
		bool IsEmpty() noexcept;

		// Return string that contains path
		// to file that must be scanned
		std::string GetTask() noexcept(false);

		// Remove all tasks from task queue
		void Clear() noexcept;

	};

	// Class for multi-thread scanner
	class Scanner {
	private:
		// Data structures for scanning
		scan::TaskQueue& tq;
		db::DBFileReader& dbfr;
		ipc::ServerPipe& pipe;
		db::RecordBatch rb;
		ipc::DetectAction dAct;
		HANDLE evSync;

		// Function for worker threads
		void Scan();

		// Scanning file function for orker threads
		bool ScanFile(std::string& file,
		  uint32_t& curBatchSize,
		  uint32_t& rIndex, std::size_t& pos);

		// Sending status about non executable file
		void SendFileStatus(std::string& file, bool isInfected,
		  std::size_t pos = 0, db::Record* rec = nullptr) noexcept;

		// Replacing infected file to quarantine folder
		void ReplaceInfected(std::string& file) noexcept;

		// Remove infected file
		void RemoveInfected(std::string& file) noexcept;

		// Waiting command for resume or stop scanning
		void SyncScanning() noexcept;

	public:
		// Delete default constructor
		explicit Scanner() noexcept = delete;

		// Constructor
		Scanner(scan::TaskQueue& _tq, db::DBFileReader& _dbfr,
			ipc::DetectAction& _dAct, HANDLE _evSync,
			ipc::ServerPipe& _pipe) noexcept;

	};

}

#endif // AM_SCAN_SCANNER_H
