#ifndef AM_SCAN_SCANNER_H
#define AM_SCAN_SCANNER_H

#include <atomic>
#include <deque>
#include <mutex>
#include <queue>
#include <string>
#include <thread>
#include <vector>
#include "am.scan.peops.hpp"
#include "am.scan.kmp.hpp"
#include "../database/am.db.recbatch.hpp"
#include "../hash/am.hash.sha256.hpp"

namespace scan {
	// Class for organisation queue of tasks
	class TaskQueue {
	private:
		std::queue<std::string> tasks;
		std::mutex mutexAccess;

		// Split string to substrings
		std::vector<std::string> SplitString(const std::string& str, char delimeter) noexcept;

		// Scan path function
		void ScanPath(std::string& path) noexcept;

		// Check is file executable
		void CheckFile(std::string& file) noexcept;

	public:
		// Constructor
		explicit TaskQueue() noexcept;

		// Parse unformated string to getting 
		// executable files in received paths
		void PassUnformatedStr(std::string unformatted);
		
		// Return size of queue of tasks
		std::size_t GetSize() noexcept;

		// Return false if queue is empty, else return true
		bool IsEmpty() noexcept;

		// Return string that contains path
		// to file that must be scanned
		std::string GetTask() noexcept;

	};

	// Class for multi-thread scanner
	class MultiThreadScanner {
	private:
		// Data for threads working
		std::size_t numWorkers;
		uint32_t currentBatchSize;
		int64_t dbSize;
		std::atomic_bool isWorking;
		mutable std::mutex syncWorkers;
		std::vector<std::thread> workers;
		std::thread master;
		std::deque<bool> rWorkersState;
		HANDLE evMStart, evMRead1, evMRead2, evMPassive;

		// Data structures for scanning
		TaskQueue* _tq;
		db::DBFileReader* _dbfr;
		db::RecordBatch* _rb;

		// Function for worker threads
		static void WorkerThread(MultiThreadScanner* _ms, bool* state);

		// Scanning file function for orker threads
		static bool ScanFile(std::string& file, db::RecordBatch* rb, uint32_t& curBatchSize);

		// Function for master thread
		static void MasterThread(MultiThreadScanner* _ms);

		// Check states of workers and wait them
		static void WaitWorkers(std::deque<bool>& states, const std::size_t& num);

	public:
		// Delete default constructor
		explicit MultiThreadScanner() noexcept = delete;

		// Constructor
		MultiThreadScanner(TaskQueue* tq, db::DBFileReader* dbfr, db::RecordBatch* rb) noexcept;

		// Closing all threads
		void Shutdown() noexcept;
		
		// Join to all threads in scanner
		void JoinThreads() noexcept;

	};

}

#endif // AM_SCAN_SCANNER_H
