#ifndef AM_SCAN_SCANNER_H
#define AM_SCAN_SCANNER_H

#include <algorithm>
#include <atomic>
#include <cassert>
#include <memory>
#include <mutex>
#include <queue>
#include <sstream>
#include <string>
#include <thread>
#include <vector>
#include "am.scan.peops.hpp"
#include "am.scan.kmp.hpp"
#include "../database/am.db.recbatch.hpp"
#include "../hash/am.hash.sha256.hpp"

namespace scan {
	// Class for organisation queue of tasks
	class TaskQueue {
	private:
		std::queue<std::string> tasks;
		std::mutex mutexAccess;

		// Split string to substrings
		std::vector<std::string> SplitString(const std::string& str, char delimeter) noexcept {
			std::vector<std::string> result;
			std::size_t numOfPaths = std::count(str.begin(), str.end(), delimeter) + 1;
			result.reserve(numOfPaths);
			std::stringstream ss(str);
			std::string item;
			while (std::getline(ss, item, delimeter)) {
				result.push_back(item);
			}
			return result;
		}

		// Scan path function
		void ScanPath(std::string& path) noexcept {
			DWORD errState = ERROR_SUCCESS;
			// If path is a directory / folder
			if (IsDirectory(path.c_str())) {
				auto file = path;
				if (file[file.length() - 1] != '\\') file += "\\*.*";
				else file += "*.*";
				WIN32_FIND_DATAA        FindData;
				HANDLE hFind = FindFirstFileA(file.c_str(), &FindData);

				// Scan files in folder
				do {
					// If getting error
					if (hFind == INVALID_HANDLE_VALUE) {
						errState = GetLastError();
						continue;
					}
					// Except folders "." and ".."
					else if (!strcmp(FindData.cFileName, ".") || !strcmp(FindData.cFileName, "..")) {
						continue;
					}
					file = path + '\\' + FindData.cFileName;
					//std::cout << file << '\n';
					// If founded folder
					if (IsDirectory(FindData.dwFileAttributes)) {
						ScanPath(file);
					}
					// If founded file
					else CheckFile(file);
				} while (FindNextFileA(hFind, &FindData));
			}
			// If path is a file
			else CheckFile(path);
		}

		// Check is file executable
		void CheckFile(std::string& file) noexcept {
			bool isExec;
			try { isExec = IsExecute(file.c_str()); }
			catch(DWORD&) { isExec = false; }
			if (isExec) {
				mutexAccess.lock();
				tasks.push(file);
				std::cout << "Executable: " << file << '\n';
				mutexAccess.unlock();
			}
			else {
				// TODO: Send message to UI Client
				// that file is OK
			}
		}

	public:
		// Constructor
		explicit TaskQueue() noexcept:
		  tasks(), mutexAccess() { }

		// Destructor
		~TaskQueue() { }

		// Parse unformated string to getting 
		// executable files in received paths
		void PassUnformatedStr(std::string unformatted) {
			char delimeter = ';';
			if (unformatted[unformatted.length() - 1] == delimeter) {
				unformatted = unformatted.substr(0, unformatted.length() - 1);
			}

			auto formatted(SplitString(unformatted, delimeter));
			for (auto& path : formatted) {
				if (path.length() > 0) ScanPath(path);
			}
		}
		
		// Return size of queue of tasks
		std::size_t GetSize() noexcept {
			mutexAccess.lock();
			std::size_t size = tasks.size();
			mutexAccess.unlock();
			return size;
		}

		// Return false if queue is empty, else return true
		bool IsEmpty() noexcept {
			mutexAccess.lock();
			bool isEmpty = tasks.empty();
			mutexAccess.unlock();
			return isEmpty;
		}

		// Return string that contains path
		// to file that must be scanned
		std::string GetTask() noexcept {
			mutexAccess.lock();
			std::string task(tasks.front());
			tasks.pop();
			mutexAccess.unlock();
			return task;
		}

	};

	/*
	// Functor struct for deleting
	// dynamic arrays in std::shared_ptr
	template<class Type>
	struct array_deleter {
		void operator()(Type const* p) {
			delete[] p;
		}
	};
	*/

	// Class for multi-thread scanner
	class MultiThreadScanner {
	private:
		// Data for threads working
		std::size_t numWorkers;
		std::size_t currentWorkers;
		uint32_t currentBatchSize;
		int64_t dbSize;
		std::atomic_bool isWorking;
		std::mutex syncWorkers;
		std::vector<std::thread> workers;
		std::thread master;
		std::vector<HANDLE> hEvWorkers;
		HANDLE hEvMaster1, hEvMaster2;

		// Data structures for scanning
		TaskQueue* _tq;
		db::DBFileReader* _dbfr;
		db::RecordBatch* _rb;

		// Function for worker threads
		static void WorkerThread(MultiThreadScanner* _ms, HANDLE hEvent) {
			std::string task;
			// Main loop
			while (_ms->isWorking) {
				// Wait signal from master thread
				WaitForSingleObject(_ms->hEvMaster1, INFINITE);
				// Getting task from queue
				if (!_ms->_tq->IsEmpty()) {
					task = _ms->_tq->GetTask();
					_ms->currentWorkers++;
					SetEvent(hEvent);
				}
				// If no more tasks wait
				else {
					std::this_thread::yield();
					Sleep(200);
					continue;
				}

				// Scanning file loop
				std::size_t iter = 0;
				bool state, finalState = false;
				while (_ms->dbSize > 0) {
					// Wait signal from master thread
					if (iter % 2 == 0) WaitForSingleObject(_ms->hEvMaster2, INFINITE);
					else WaitForSingleObject(_ms->hEvMaster1, INFINITE);
					
					state = ScanFile(task, _ms->_rb, _ms->currentBatchSize);
					if (state) {
						std::cout << task << " is infected\n";
						finalState = true;
					}
					SetEvent(hEvent);
					iter++;
				}
				if (!finalState) {
					std::cout << task << " is Ok\n";
				}

			}
		}

		// Scanning file function for orker threads
		static bool ScanFile(std::string& file, db::RecordBatch* rb, uint32_t& curBatchSize) {
			// Section of code
			auto cHeader(GetCodeSection(file.c_str()));
			auto code = new uint8_t[cHeader.SizeOfRawData];
			// Open executable file
			std::ifstream scanned(file.c_str());
			scanned.seekg(cHeader.PointerToRawData, std::ios::beg);
			scanned.read(reinterpret_cast<char*>(code), cHeader.SizeOfRawData);
			scanned.close();

			// Get all records from batch
			auto records(rb->GetRecords());
			for (uint32_t i = 0; i < curBatchSize; i++) {
				auto indexes(KMPMatch::IndexesOf(code, cHeader.SizeOfRawData, records[i].Signature.FirstBytes, 8));
				for (auto& index : indexes) {
					auto iHash(hash::GetSHA256(code + index, records[i].Signature.Length));
					// Signature founded
					if (iHash == records[i].Signature.Hash) {
						return true;
					}
				}
			}
			return false;
		}

		// Function for master thread
		static void MasterThread(MultiThreadScanner* _ms) {
			// Main loop
			while (_ms->isWorking) {
				if (_ms->_tq->IsEmpty()) Sleep(400);
				else {
					// Set start values
					_ms->currentWorkers = 0;
					std::size_t queueSize(_ms->_tq->GetSize());
					//
					MasterNotifyAndWait(queueSize, _ms->numWorkers,
						_ms->currentWorkers, _ms->hEvWorkers.data(),
						_ms->hEvMaster1);

					/*
					// Worker threads was signalized
					SetEvent(_ms->hEvMaster1);

					// If number of tasks is greater or equal
					// than number of worker threads
					DWORD timeout;
					if (queueSize >= _ms->numWorkers) timeout = INFINITE;
					// If number of tasks is fewer
					// than number of worker threads
					else timeout = 10;

					// Wait until workers have tasks
					for (std::size_t i = 0; i < _ms->numWorkers; i++) {
						WaitForSingleObject(_ms->hEvWorkers.get()[i], timeout);
					}
					// Assert values
					if (queueSize >= _ms->numWorkers) assert(_ms->currentWorkers == _ms->numWorkers);
					else assert(_ms->currentWorkers == queueSize);
					ResetEvent(_ms->hEvMaster1);
					*/

					_ms->dbSize = static_cast<int64_t>(_ms->_dbfr->GetRecordCount());
					uint32_t batchSize(_ms->_rb->GetBatchSize());
					std::size_t iter = 0;

					while (_ms->dbSize > 0) {
						_ms->currentBatchSize = _ms->_rb->ReadRecords(*_ms->_dbfr);
						//
						if (iter % 2 == 0) {
							MasterNotifyAndWait(queueSize, _ms->numWorkers,
							_ms->currentWorkers, _ms->hEvWorkers.data(), _ms->hEvMaster2);
						}
						else {
							MasterNotifyAndWait(queueSize, _ms->numWorkers,
							_ms->currentWorkers, _ms->hEvWorkers.data(), _ms->hEvMaster1);
						}

						_ms->dbSize -= batchSize;
						iter++;
					}


				}
			}
		}

		// Master thread notify workers threads and wait response
		static void MasterNotifyAndWait(std::size_t& queueSize, std::size_t& numWorkers,
		  std::size_t& curWorkers, const HANDLE* workersEvents, const HANDLE notifyEvent) {
			// Worker threads was signalized
			SetEvent(notifyEvent);
			// If number of tasks is greater or equal
			// than number of worker threads
			DWORD timeout;
			if (queueSize >= numWorkers) timeout = INFINITE;
			// If number of tasks is fewer
			// than number of worker threads
			else timeout = 10;

			// Wait until workers have tasks
			for (std::size_t i = 0; i < numWorkers; i++) {
				WaitForSingleObject(workersEvents[i], timeout);
			}
			// Assert values
			//if (queueSize >= numWorkers) assert(curWorkers == numWorkers);
			//else assert(curWorkers == queueSize);
			ResetEvent(notifyEvent);
		}

	public:
		// Delete default constructor
		explicit MultiThreadScanner() noexcept = delete;

		// Constructor
		MultiThreadScanner(TaskQueue* tq, db::DBFileReader* dbfr, db::RecordBatch* rb) noexcept:
		  numWorkers(std::thread::hardware_concurrency()), currentWorkers(0),
		  currentBatchSize(0), dbSize(0), isWorking(true), syncWorkers(),
		  workers(), hEvWorkers(), _tq(tq), _dbfr(dbfr), _rb(rb) {
			try {
				// Master's thread events
				hEvMaster1 = CreateEventA(NULL, TRUE, FALSE, "evMasterSync1");
				hEvMaster2 = CreateEventA(NULL, TRUE, FALSE, "evMasterSync2");
				if (hEvMaster1 == NULL || hEvMaster2 == NULL) throw;

				// Initial actions for worker threads
				workers.reserve(numWorkers);
				hEvWorkers.reserve(numWorkers);
				for (std::size_t i = 0; i < numWorkers; i++) {
					auto workerEventName("evWorkerSync" + std::to_string(i));
					HANDLE temp = CreateEventA(NULL, FALSE, FALSE, workerEventName.c_str());
					if (temp != NULL) hEvWorkers.push_back(temp);
					else throw;
					workers.push_back(std::thread(WorkerThread, this, hEvWorkers[i]));
					workers[i].detach();
				}

				// Initial master thread
				master = std::thread(MasterThread, this);
				master.detach();
			}
			catch (...) {
				isWorking = false;
			}
		}

		// Closing all threads
		void Shutdown() {
			isWorking = false;
			Sleep(401);
		}
		
		// Join to all threads in scanner
		void JoinThreads() {
			for (std::size_t i = 0; i < numWorkers; i++) {
				if (workers[i].joinable()) {
					workers[i].join();
				}
			}
			if (master.joinable()) master.join();
		}

	};

}

#endif // AM_SCAN_SCANNER_H
