#ifndef AM_SCAN_SCANNER_H
#define AM_SCAN_SCANNER_H

#include <algorithm>
#include <memory>
#include <queue>
#include <sstream>
#include <string>
#include <vector>
#include "am.scan.peops.hpp"
#include "../database/am.db.recbatch.hpp"

// Exception codes
#define ERROR_EMPTY_PATH 0x0001

namespace scan {
	// Class for organisation queue of tasks
	class TaskQueue {
	private:
		std::queue<std::string> tasks;
		HANDLE hMutexAccess;

		// Split string to substrings
		std::vector<std::string> SplitString(const std::string& str, char delimeter) noexcept {
			std::vector<std::string> result;
			std::size_t numOfPaths = std::count(str.begin(), str.end(), delimeter) + 1;
			result.reserve(numOfPaths);
			std::stringstream ss(str);
			std::string item;
			while (std::getline(ss, item, delimeter)) {
				result.push_back(item);
			}
			return result;
		}

		// Scan path function
		void ScanPath(std::string& path) noexcept {
			DWORD errState = ERROR_SUCCESS;
			// If path is a directory / folder
			if (IsDirectory(path.c_str())) {
				auto file = path;
				if (file[file.length() - 1] != '\\') file += "\\*.*";
				else file += "*.*";
				WIN32_FIND_DATAA        FindData;
				HANDLE hFind = FindFirstFileA(file.c_str(), &FindData);

				// Scan files in folder
				do {
					// If getting error
					if (hFind == INVALID_HANDLE_VALUE) {
						errState = GetLastError();
						continue;
					}
					// Except folders "." and ".."
					else if (!strcmp(FindData.cFileName, ".") || !strcmp(FindData.cFileName, "..")) {
						continue;
					}
					file = path + '\\' + FindData.cFileName;
					//std::cout << file << '\n';
					// If founded folder
					if (IsDirectory(FindData.dwFileAttributes)) {
						ScanPath(file);
					}
					// If founded file
					else CheckFile(file);
				} while (FindNextFileA(hFind, &FindData));
			}
			// If path is a file
			else CheckFile(path);
		}

		// Check is file executable
		void CheckFile(std::string& file) noexcept {
			bool isExec;
			try { isExec = IsExecute(file.c_str()); }
			catch(DWORD&) { isExec = false; }
			if (isExec) {
				WaitForSingleObject(hMutexAccess, INFINITE);
				tasks.push(file);
				ReleaseMutex(hMutexAccess);
			}
			else {
				// TODO: Send message to UI Client
				// that file is OK
			}
		}

	public:
		// Constructor
		explicit TaskQueue() noexcept(false):
		  tasks(), hMutexAccess(NULL) {
			hMutexAccess = CreateMutex(NULL, FALSE, TEXT("TaskQueueMutex"));
			if (hMutexAccess == NULL) {
				throw DWORD(GetLastError());
			}
		}

		// Destructor
		~TaskQueue() {
			CloseHandle(hMutexAccess);
		}

		// Parse unformated string to getting 
		// executable files in received paths
		void PassUnformatedStr(std::string unformatted) {
			char delimeter = ';';
			if (unformatted[unformatted.length() - 1] == delimeter) {
				unformatted = unformatted.substr(0, unformatted.length() - 1);
			}

			auto formatted(SplitString(unformatted, delimeter));
			for (auto& path : formatted) {
				ScanPath(path);
			}
		}
		
		// Return size of queue of tasks
		std::size_t GetSize() noexcept {
			WaitForSingleObject(hMutexAccess, INFINITE);
			std::size_t size = tasks.size();
			ReleaseMutex(hMutexAccess);
			return size;
		}

		// Return false if queue is empty, else return true
		bool IsEmpty() noexcept {
			WaitForSingleObject(hMutexAccess, INFINITE);
			bool isEmpty = tasks.empty();
			ReleaseMutex(hMutexAccess);
			return isEmpty;
		}

		// Return string that contains path
		// to file that must be scanned
		std::string GetTask() noexcept {
			WaitForSingleObject(hMutexAccess, INFINITE);
			std::string task(tasks.front());
			tasks.pop();
			ReleaseMutex(hMutexAccess);
			return task;
		}

	};

	// Class 
	class MultiScanner {
	private:
		std::shared_ptr<std::thread[]> workers;
		std::thread master;

	public:
		MultiScanner() {

		}
		
	};

}

#endif // AM_SCAN_SCANNER_H
