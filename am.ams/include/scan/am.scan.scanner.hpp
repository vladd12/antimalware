#ifndef AM_SCAN_SCANNER_H
#define AM_SCAN_SCANNER_H

#include <algorithm>
#include <atomic>
#include <cassert>
#include <deque>
#include <mutex>
#include <queue>
#include <sstream>
#include <string>
#include <thread>
#include <vector>
#include "am.scan.peops.hpp"
#include "am.scan.kmp.hpp"
#include "../database/am.db.recbatch.hpp"
#include "../hash/am.hash.sha256.hpp"

namespace scan {
	// Class for organisation queue of tasks
	class TaskQueue {
	private:
		std::queue<std::string> tasks;
		std::mutex mutexAccess;

		// Split string to substrings
		std::vector<std::string> SplitString(const std::string& str, char delimeter) noexcept {
			std::vector<std::string> result;
			std::size_t numOfPaths = std::count(str.begin(), str.end(), delimeter) + 1;
			result.reserve(numOfPaths);
			std::stringstream ss(str);
			std::string item;
			while (std::getline(ss, item, delimeter)) {
				result.push_back(item);
			}
			return result;
		}

		// Scan path function
		void ScanPath(std::string& path) noexcept {
			DWORD errState = ERROR_SUCCESS;
			// If path is a directory / folder
			if (IsDirectory(path.c_str())) {
				auto file = path;
				if (file[file.length() - 1] != '\\') file += "\\*.*";
				else file += "*.*";
				WIN32_FIND_DATAA        FindData;
				HANDLE hFind = FindFirstFileA(file.c_str(), &FindData);

				// Scan files in folder
				do {
					// If getting error
					if (hFind == INVALID_HANDLE_VALUE) {
						errState = GetLastError();
						continue;
					}
					// Except folders "." and ".."
					else if (!strcmp(FindData.cFileName, ".") || !strcmp(FindData.cFileName, "..")) {
						continue;
					}
					file = path + '\\' + FindData.cFileName;
					//std::cout << file << '\n';
					// If founded folder
					if (IsDirectory(FindData.dwFileAttributes)) {
						ScanPath(file);
					}
					// If founded file
					else CheckFile(file);
				} while (FindNextFileA(hFind, &FindData));
			}
			// If path is a file
			else CheckFile(path);
		}

		// Check is file executable
		void CheckFile(std::string& file) noexcept {
			bool isExec;
			try { isExec = IsExecute(file.c_str()); }
			catch(DWORD&) { isExec = false; }
			if (isExec) {
				mutexAccess.lock();
				tasks.push(file);
				std::cout << "Executable: " << file << '\n';
				mutexAccess.unlock();
			}
			else {
				// TODO: Send message to UI Client that file is OK
			}
		}

	public:
		// Constructor
		explicit TaskQueue() noexcept:
		  tasks(), mutexAccess() { }

		// Destructor
		~TaskQueue() { }

		// Parse unformated string to getting 
		// executable files in received paths
		void PassUnformatedStr(std::string unformatted) {
			char delimeter = ';';
			if (unformatted[unformatted.length() - 1] == delimeter) {
				unformatted = unformatted.substr(0, unformatted.length() - 1);
			}

			auto formatted(SplitString(unformatted, delimeter));
			for (auto& path : formatted) {
				if (path.length() > 0) ScanPath(path);
			}
		}
		
		// Return size of queue of tasks
		std::size_t GetSize() noexcept {
			mutexAccess.lock();
			std::size_t size = tasks.size();
			mutexAccess.unlock();
			return size;
		}

		// Return false if queue is empty, else return true
		bool IsEmpty() noexcept {
			mutexAccess.lock();
			bool isEmpty = tasks.empty();
			mutexAccess.unlock();
			return isEmpty;
		}

		// Return string that contains path
		// to file that must be scanned
		std::string GetTask() noexcept {
			mutexAccess.lock();
			std::string task(tasks.front());
			tasks.pop();
			mutexAccess.unlock();
			return task;
		}

	};

	// Class for multi-thread scanner
	class MultiThreadScanner {
	private:
		// Data for threads working
		std::size_t numWorkers;
		uint32_t currentBatchSize;
		int64_t dbSize;
		std::atomic_bool isWorking;
		mutable std::mutex syncWorkers;
		std::vector<std::thread> workers;
		std::thread master;
		std::deque<bool> rWorkersState;
		HANDLE evMStart, evMRead1, evMRead2, evMPassive;

		// Data structures for scanning
		TaskQueue* _tq;
		db::DBFileReader* _dbfr;
		db::RecordBatch* _rb;

		// Function for worker threads
		static void WorkerThread(MultiThreadScanner* _ms, bool* state) {
			std::string task;
			// Main loop
			while (_ms->isWorking) {
				// Wait signal from master thread
				WaitForSingleObject(_ms->evMStart, INFINITE);
				// Getting task from queue
				_ms->syncWorkers.lock();
				if (!_ms->_tq->IsEmpty()) {
					task = _ms->_tq->GetTask();
					*state = true;
					_ms->syncWorkers.unlock();

					// Scanning file loop
					bool scanState, finalState = false;
					// Wait signal from master thread
					WaitForSingleObject(_ms->evMRead1, INFINITE);
					while (_ms->dbSize > 0) {
						// Scanning file
						scanState = ScanFile(task, _ms->_rb, _ms->currentBatchSize);
						if (scanState) {
							// TODO: Send message to UI Client that file is bad
							std::cout << task << " is infected\n";
							finalState = true;
						}
						*state = true;
						// Wait signal from master thread
						WaitForSingleObject(_ms->evMRead2, INFINITE);
					}
					// TODO: Send message to UI Client that file is OK
					if (!finalState) {
						std::cout << task << " is Ok\n";
					}
				}
				// If no more tasks thread is passive
				else {
					_ms->syncWorkers.unlock();
					std::this_thread::yield();
					WaitForSingleObject(_ms->evMPassive, INFINITE);
					*state = true;
				}
			}
		}

		// TODO: Must return pointer to signature
		// Scanning file function for orker threads
		static bool ScanFile(std::string& file, db::RecordBatch* rb, uint32_t& curBatchSize) {
			// Section of code
			auto cHeader(GetCodeSection(file.c_str()));
			auto code = new uint8_t[cHeader.SizeOfRawData];
			// Open executable file
			std::ifstream scanned(file.c_str());
			scanned.seekg(cHeader.PointerToRawData, std::ios::beg);
			scanned.read(reinterpret_cast<char*>(code), cHeader.SizeOfRawData);
			scanned.close();

			// Get all records from batch
			auto records(rb->GetRecords());
			for (uint32_t i = 0; i < curBatchSize; i++) {
				auto indexes(KMPMatch::IndexesOf(code, cHeader.SizeOfRawData, records[i].Signature.FirstBytes, 8));
				for (auto& index : indexes) {
					auto iHash(hash::GetSHA256(code + index, records[i].Signature.Length));
					// Signature founded
					if (iHash == records[i].Signature.Hash) {
						return true;
					}
				}
			}
			return false;
		}

		// Function for master thread
		static void MasterThread(MultiThreadScanner* _ms) {
			std::size_t queueSize(0), currentWorkers(0), passive(0);
			// Main loop
			while (_ms->isWorking) {
				if (_ms->_tq->IsEmpty()) std::this_thread::yield();
				else {
					// Set start values
					queueSize = _ms->_tq->GetSize();
					if (queueSize >= _ms->numWorkers) {
						currentWorkers = _ms->numWorkers;
						passive = 0;
					}
					else {
						currentWorkers = queueSize;
						passive = _ms->numWorkers - queueSize;
					}

					// Set read event
					SetEvent(_ms->evMStart);
					// Wait workers
					WaitWorkers(_ms->rWorkersState, currentWorkers);
					ResetEvent(_ms->evMStart);

					// Read DB and RecordBatch info
					_ms->dbSize = static_cast<int64_t>(_ms->_dbfr->GetRecordCount());
					uint32_t batchSize(_ms->_rb->GetBatchSize());
					// Loop of reading batch from DB
					while (_ms->dbSize > 0) {
						_ms->currentBatchSize = _ms->_rb->ReadRecords(*_ms->_dbfr);
						SetEvent(_ms->evMRead1);
						ResetEvent(_ms->evMRead2);
						WaitWorkers(_ms->rWorkersState, currentWorkers);
						ResetEvent(_ms->evMRead1);
						_ms->dbSize -= batchSize;
						SetEvent(_ms->evMRead2);
					}
					_ms->_dbfr->SetToStart();

					// If we have threads in passive mode
					if (queueSize < _ms->numWorkers) {
						SetEvent(_ms->evMPassive);
						WaitWorkers(_ms->rWorkersState, passive);
						ResetEvent(_ms->evMPassive);
					}
				}
			}
		}

		// Check states of workers and wait them
		static void WaitWorkers(std::deque<bool>& states, const std::size_t& num) {
			std::size_t i = 0;
			// Wait while [num] of workers will set state to true
			while (i != num) {
				for (auto& state : states) {
					if (state) i++;
				}
				if (i != num) {
					i = 0;
					std::this_thread::yield();
				}
			}
			// Reset state array
			for (auto& state : states) {
				state = false;
			}
		}

	public:
		// Delete default constructor
		explicit MultiThreadScanner() noexcept = delete;

		// Constructor
		MultiThreadScanner(TaskQueue* tq, db::DBFileReader* dbfr, db::RecordBatch* rb) noexcept:
		  numWorkers(std::thread::hardware_concurrency()), currentBatchSize(0), dbSize(0),
		  isWorking(true), syncWorkers(), workers(), rWorkersState(numWorkers, false),
		  evMStart(NULL), evMRead1(NULL), evMRead2(NULL), evMPassive(NULL),
		  _tq(tq), _dbfr(dbfr), _rb(rb) {
			try {
				// Master thread's events
				evMStart = CreateEventA(NULL, TRUE, FALSE, "evMasterStart");
				evMRead1 = CreateEventA(NULL, TRUE, FALSE, "evMasterRead1");
				evMRead2 = CreateEventA(NULL, TRUE, FALSE, "evMasterRead2");
				evMPassive = CreateEventA(NULL, TRUE, FALSE, "evMasterPassive");
				if (evMStart == NULL || evMRead1 == NULL ||
					evMRead2 == NULL || evMPassive == NULL) throw;

				// Initial actions for worker threads
				workers.reserve(numWorkers);
				for (std::size_t i = 0; i < numWorkers; i++) {
					workers.push_back(std::thread(WorkerThread, this, &rWorkersState[i]));
					workers[i].detach();
				}

				// Initial master thread
				master = std::thread(MasterThread, this);
				master.detach();
			}
			catch (...) {
				isWorking = false;
			}
		}

		// Closing all threads
		void Shutdown() {
			isWorking = false;
		}
		
		// Join to all threads in scanner
		void JoinThreads() {
			for (std::size_t i = 0; i < numWorkers; i++) {
				if (workers[i].joinable()) {
					workers[i].join();
				}
			}
			if (master.joinable()) master.join();
		}

	};

}

#endif // AM_SCAN_SCANNER_H
