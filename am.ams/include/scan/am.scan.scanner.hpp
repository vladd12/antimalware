#ifndef AM_SCAN_SCANNER_H
#define AM_SCAN_SCANNER_H

#include <atomic>
#include <deque>
#include <mutex>
#include <queue>
#include <string>
#include <thread>
#include <vector>
#include "am.auth.protocol.hpp"
#include "am.scan.peops.hpp"
#include "am.scan.kmp.hpp"
#include "../database/am.db.recbatch.hpp"
#include "../hash/am.hash.sha256.hpp"

namespace scan {
	// Class for organisation queue of tasks
	class TaskQueue {
	private:
		std::queue<std::string> tasks;
		ipc::ServerPipe& spipe;

		// Split string to substrings
		std::vector<std::string> SplitString(const std::string& str, char delimeter) noexcept;

		// Scan path function
		void ScanPath(std::string& path) noexcept;

		// Check is file executable
		void CheckFile(std::string& file) noexcept;

		// Sending status about non executable file
		void SendFileStatus(std::string& file) noexcept;

	public:
		// Delete default constructor
		explicit TaskQueue() noexcept = delete;

		// Constructor with params
		explicit TaskQueue(ipc::ServerPipe& pipe) noexcept;

		// Parse unformated string to getting 
		// executable files in received paths
		void PassUnformatedStr(std::string unformatted);
		
		// Return size of queue of tasks
		std::size_t GetSize() noexcept;

		// Return false if queue is empty, else return true
		bool IsEmpty() noexcept;

		// Return string that contains path
		// to file that must be scanned
		std::string GetTask() noexcept(false);

	};

	// Class for multi-thread scanner
	class MultiThreadScanner {
	private:
		// Data for threads working
		std::size_t numWorkers;
		uint32_t currentBatchSize;
		int64_t dbSize;
		std::atomic_bool isWorking;
		mutable std::mutex sync1;
		mutable std::mutex sync2;
		std::vector<std::thread> workers;

		// Data structures for scanning
		TaskQueue* _tq;
		db::DBFileReader* _dbfr;
		db::RecordBatch* _rb;
		ipc::ServerPipe* _pipe;

		// Function for worker threads
		static void WorkerThread(MultiThreadScanner* _ms);

		// Scanning file function for orker threads
		static bool ScanFile(std::string& file, db::RecordBatch* rb,
		  uint32_t& curBatchSize, uint32_t& rIndex, std::size_t& pos);

		// Sending status about non executable file
		static void MultiThreadScanner::SendFileStatus(std::string& file, bool isInfected,
		  ipc::ServerPipe* spipe, std::size_t pos = 0, db::Record* rec = nullptr) noexcept;

	public:
		// Delete default constructor
		explicit MultiThreadScanner() noexcept = delete;

		// Constructor
		MultiThreadScanner(TaskQueue* tq, db::DBFileReader* dbfr,
			db::RecordBatch* rb, ipc::ServerPipe* pipe) noexcept;

		// Closing all threads
		void Shutdown() noexcept;
		
		// Join to all threads in scanner
		void JoinThreads() noexcept;

	};

}

#endif // AM_SCAN_SCANNER_H
