#ifndef AM_SCAN_SCANNER_H
#define AM_SCAN_SCANNER_H

#include <algorithm>
#include <memory>
#include <queue>
#include <sstream>
#include <string>
#include <thread>
#include <vector>
#include "am.scan.peops.hpp"
#include "../database/am.db.recbatch.hpp"

namespace scan {
	// Class for organisation queue of tasks
	class TaskQueue {
	private:
		std::queue<std::string> tasks;
		HANDLE hMutexAccess;

		// Split string to substrings
		std::vector<std::string> SplitString(const std::string& str, char delimeter) noexcept {
			std::vector<std::string> result;
			std::size_t numOfPaths = std::count(str.begin(), str.end(), delimeter) + 1;
			result.reserve(numOfPaths);
			std::stringstream ss(str);
			std::string item;
			while (std::getline(ss, item, delimeter)) {
				result.push_back(item);
			}
			return result;
		}

		// Scan path function
		void ScanPath(std::string& path) noexcept {
			DWORD errState = ERROR_SUCCESS;
			// If path is a directory / folder
			if (IsDirectory(path.c_str())) {
				auto file = path;
				if (file[file.length() - 1] != '\\') file += "\\*.*";
				else file += "*.*";
				WIN32_FIND_DATAA        FindData;
				HANDLE hFind = FindFirstFileA(file.c_str(), &FindData);

				// Scan files in folder
				do {
					// If getting error
					if (hFind == INVALID_HANDLE_VALUE) {
						errState = GetLastError();
						continue;
					}
					// Except folders "." and ".."
					else if (!strcmp(FindData.cFileName, ".") || !strcmp(FindData.cFileName, "..")) {
						continue;
					}
					file = path + '\\' + FindData.cFileName;
					//std::cout << file << '\n';
					// If founded folder
					if (IsDirectory(FindData.dwFileAttributes)) {
						ScanPath(file);
					}
					// If founded file
					else CheckFile(file);
				} while (FindNextFileA(hFind, &FindData));
			}
			// If path is a file
			else CheckFile(path);
		}

		// Check is file executable
		void CheckFile(std::string& file) noexcept {
			bool isExec;
			try { isExec = IsExecute(file.c_str()); }
			catch(DWORD&) { isExec = false; }
			if (isExec) {
				WaitForSingleObject(hMutexAccess, INFINITE);
				tasks.push(file);
				ReleaseMutex(hMutexAccess);
			}
			else {
				// TODO: Send message to UI Client
				// that file is OK
			}
		}

	public:
		// Constructor
		explicit TaskQueue() noexcept(false):
		  tasks(), hMutexAccess(NULL) {
			hMutexAccess = CreateMutex(NULL, FALSE, TEXT("TaskQueueMutex"));
			if (hMutexAccess == NULL) {
				throw DWORD(GetLastError());
			}
		}

		// Destructor
		~TaskQueue() {
			CloseHandle(hMutexAccess);
		}

		// Parse unformated string to getting 
		// executable files in received paths
		void PassUnformatedStr(std::string unformatted) {
			char delimeter = ';';
			if (unformatted[unformatted.length() - 1] == delimeter) {
				unformatted = unformatted.substr(0, unformatted.length() - 1);
			}

			auto formatted(SplitString(unformatted, delimeter));
			for (auto& path : formatted) {
				ScanPath(path);
			}
		}
		
		// Return size of queue of tasks
		std::size_t GetSize() noexcept {
			WaitForSingleObject(hMutexAccess, INFINITE);
			std::size_t size = tasks.size();
			ReleaseMutex(hMutexAccess);
			return size;
		}

		// Return false if queue is empty, else return true
		bool IsEmpty() noexcept {
			WaitForSingleObject(hMutexAccess, INFINITE);
			bool isEmpty = tasks.empty();
			ReleaseMutex(hMutexAccess);
			return isEmpty;
		}

		// Return string that contains path
		// to file that must be scanned
		std::string GetTask() noexcept {
			WaitForSingleObject(hMutexAccess, INFINITE);
			std::string task(tasks.front());
			tasks.pop();
			ReleaseMutex(hMutexAccess);
			return task;
		}

	};

	// Functor struct for delete
	// dynamic arrays in std::shared_ptr
	template<class Type>
	struct array_deleter {
		void operator()(Type const* p) {
			delete[] p;
		}
	};

	// Class for multi-thread scanner
	class MultiThreadScanner {
	private:
		// Threads
		std::size_t numWorkers;
		bool isWorking;
		std::shared_ptr<std::thread> workers;
		std::thread master;
		std::shared_ptr<HANDLE> hEvWorkers;
		HANDLE hEvMaster;

		// Data structures for scanning
		TaskQueue& _tq;
		db::DBFileReader& _dbfr;
		db::RecordBatch& _rb;

		// Function for worker threads
		static void WorkerThread(MultiScanner* _ms, HANDLE hEvent) {
			// Main loop
			while (_ms->isWorking) {
				std::string task;
				// Wait signal from master thread
				WaitForSingleObject(_ms->hEvMaster, INFINITE);
				if (!_ms->_tq.IsEmpty()) {
					task = _ms->_tq.GetTask();
					SetEvent(hEvent);
				}
				else {
					Sleep(100);
					continue;
				}
			}
		}

		// Function for master thread
		static void MasterThread(MultiScanner* _ms) {
			// Main loop
			while (_ms->isWorking) {
				if (_ms->_tq.IsEmpty()) Sleep(400);
				else {
					// If number of tasks is greater or equal
					// than number of worker threads
					std::size_t queueSize(_ms->_tq.GetSize());
					if (queueSize >= _ms->numWorkers) {
						// Worker threads signalize to read tasks from queue
						SetEvent(_ms->hEvMaster);
						// Wait until all workers have tasks
						for (std::size_t i = 0; i < _ms->numWorkers; i++) {
							WaitForSingleObject(_ms->hEvWorkers.get()[i], INFINITE);
							ResetEvent(_ms->hEvWorkers.get()[i]);
						}
						ResetEvent(_ms->hEvMaster);
					}
					// If number of tasks is fewer
					// than number of worker threads
					else {

					}
				}
			}
		}

	public:
		// Delete default constructor
		explicit MultiScanner() noexcept = delete;

		// Constructor
		MultiScanner(TaskQueue& tq, db::DBFileReader& dbfr, db::RecordBatch& rb):
		  numWorkers(std::thread::hardware_concurrency()), isWorking(true),
		  workers(new std::thread[numWorkers], array_deleter<std::thread>()),
		  hEvWorkers(new HANDLE[numWorkers], array_deleter<HANDLE>()), hEvMaster(NULL),
		  _tq(tq), _dbfr(dbfr), _rb(rb) {
			// Initial actions for master thread
			hEvMaster = CreateEventA(NULL, TRUE, FALSE, "evMasterSync");
			master = std::thread(MasterThread, this);
			master.detach();

			// Initial actions for worker threads
			for (std::size_t i = 0; i < numWorkers; i++) {
				auto workerEventName("evWorkerSync" + std::to_string(i));
				hEvWorkers.get()[i] = CreateEventA(NULL, TRUE, FALSE, workerEventName.c_str());
				workers.get()[i] = std::thread(WorkerThread, this, hEvWorkers.get()[i]);
				workers.get()[i].detach();
			}

		}
		
	};

}

#endif // AM_SCAN_SCANNER_H
