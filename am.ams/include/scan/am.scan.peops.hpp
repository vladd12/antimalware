#ifndef AM_SCAN_PE_OPS_H
#define AM_SCAN_PE_OPS_H

#include <cstdint>
#include <fstream>
#include <iostream>
#include <stdexcept>
#include <Windows.h>

// Exception codes
#define ERROR_EMPTY_PATH               0x0001   
#define ERROR_FILE_NOT_EXIST           0x0002
#define ERROR_FILE_NOT_OPEN            0x0003
#define ERROR_INCORRECT_BIT_SUBSYSTEM  0x0004

namespace scan {
	// t1
	bool IsExecute(PCSTR filePath) noexcept(false) {
		// File checks
		if (filePath == nullptr || filePath == NULL) {
			throw int(ERROR_EMPTY_PATH);
		}
		else if (GetFileAttributesA(filePath) == INVALID_FILE_ATTRIBUTES) {
			throw int(ERROR_FILE_NOT_EXIST);
		}
		else {
			std::ifstream file(filePath, std::ios::in | std::ios::binary);
			if (!file.is_open()) {
				throw int(ERROR_FILE_NOT_OPEN);
			}
			// All checks are passed
			else {
				// Read DOS header
				IMAGE_DOS_HEADER _dos_header { 0 };
				file.read(reinterpret_cast<char*>(&_dos_header), sizeof(_dos_header));
				// Check DOS header
				if (_dos_header.e_magic == 0x5a4d) {
					if (_dos_header.e_lfanew > 0) {
						// Read PE signature
						file.seekg(_dos_header.e_lfanew, std::ios::beg);
						uint32_t peSignature = 0;
						file.read(reinterpret_cast<char*>(&peSignature), sizeof(peSignature));
						file.close();
						// Check PE signature
						if (peSignature == 0x4550) return true;
						else return false;
					}
					else return false;
				}
				else return false;
			}
		}
	}

	// t2
	IMAGE_SECTION_HEADER GetCodeSection(PCSTR filePath) noexcept(false) {
		std::ifstream file(filePath, std::ios::in | std::ios::binary);
		if (!file.is_open()) {
			throw int(ERROR_FILE_NOT_OPEN);
		}
		else {
			// Read file header
			uint32_t peOffset = 0;
			file.seekg(0x3c, std::ios::beg);
			file.read(reinterpret_cast<char*>(&peOffset), sizeof(peOffset));
			file.seekg(peOffset + 0x4, std::ios::beg);
			IMAGE_FILE_HEADER fileHeader { 0 };
			file.read(reinterpret_cast<char*>(&fileHeader), sizeof(fileHeader));
			// Read magic from optional header
			uint16_t magic = 0;
			file.read(reinterpret_cast<char*>(&magic), sizeof(magic));
			
			// Executable 32 bit check
			if (fileHeader.SizeOfOptionalHeader == sizeof(IMAGE_OPTIONAL_HEADER32)) {
				if (magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
					throw int(ERROR_INCORRECT_BIT_SUBSYSTEM);
				}
			}
			// Executable 64 bit check
			else if (fileHeader.SizeOfOptionalHeader == sizeof(IMAGE_OPTIONAL_HEADER64)) {
				if (magic != IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
					throw int(ERROR_INCORRECT_BIT_SUBSYSTEM);
				}
			}
			// ROM-file check
			else {
				if (magic != IMAGE_ROM_OPTIONAL_HDR_MAGIC) {
					throw int(ERROR_INCORRECT_BIT_SUBSYSTEM);
				}
			}

			// Read entry point address from optional header
			uint32_t entryPointAddr = 0;
			file.seekg(peOffset + 0x4 + sizeof(IMAGE_FILE_HEADER) + 0x10, std::ios::beg);
			file.read(reinterpret_cast<char*>(&entryPointAddr), sizeof(entryPointAddr));
			// Read section headers
			IMAGE_SECTION_HEADER* sectionHeaders = new IMAGE_SECTION_HEADER[fileHeader.NumberOfSections];
			file.seekg(peOffset + 0x4 + sizeof(IMAGE_FILE_HEADER) + fileHeader.SizeOfOptionalHeader, std::ios::beg);
			file.read(reinterpret_cast<char*>(sectionHeaders), fileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER));
			IMAGE_SECTION_HEADER codeSection { 0 };

			// Search for section of code
			for (std::size_t i = 0; i < fileHeader.NumberOfSections; i++) {
				DWORD startVirtualAddress = sectionHeaders[i].VirtualAddress;
				DWORD endVirtualAddress = sectionHeaders[i].VirtualAddress + sectionHeaders[i].Misc.VirtualSize;
				if (entryPointAddr >= startVirtualAddress && entryPointAddr < endVirtualAddress) {
					codeSection = sectionHeaders[i];
					break;
				}
			}
			// Return the found value
			delete[] sectionHeaders;
			file.close();
			return codeSection;
		}
	}
	
	// t3
	bool IsDirectory(PCSTR path) {
		if (GetFileAttributesA(path) & FILE_ATTRIBUTE_DIRECTORY) {
			return true;
		}
		else return false;
	}

	// t4
	bool IsDirectory(PCWSTR path) {
		if (GetFileAttributesW(path) & FILE_ATTRIBUTE_DIRECTORY) {
			return true;
		}
		else return false;
	}

}

#endif // AM_SCAN_PE_OPS_H
