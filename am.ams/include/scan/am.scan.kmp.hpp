#ifndef AM_SCAN_KMP_H
#define AM_SCAN_KMP_H

#include <cstdint>
#include <cstdlib>
#include <vector>

namespace scan {
	// Knuth-Morris-Pratt Algorithm for pattern matching in data
	class KMPMatch {
	private:
		// Computes the failure function using a boot-strapping process,
		// where the pattern is matched against itself
		static void ComputeFailure(std::vector<std::size_t>& failure,
			const uint8_t* pattern, const std::size_t patternSize) {
			long long j = 0;
			for (std::size_t i = 1; i < patternSize; i++) {
				while (j > 0 && pattern[j] != pattern[i]) {
					j = failure[j - 1];
				}
				if (pattern[j] == pattern[i]) j++;
				failure[i] = j;
			}
		}

	public:
		// Finds all occurrence of the pattern in the data
		static std::vector<std::size_t> IndexesOf(const uint8_t* data, const std::size_t dataSize,
		  const uint8_t* pattern, const std::size_t patternSize) {
			std::vector<std::size_t> indexes;
			indexes.reserve(16);
			if (dataSize == 0 || patternSize == 0) indexes.push_back(UINT64_MAX);
			else {
				std::vector<std::size_t> failure(patternSize, 0);
				ComputeFailure(failure, pattern, patternSize);
				long long j = 0;

				for (std::size_t i = 0; i < dataSize; i++) {
					while (j > 0 && pattern[j] != data[i]) {
						j = failure[j - 1];
					}
					if (pattern[j] == data[i]) j++;
					if (j == patternSize) indexes.push_back(i - patternSize + 1);
				}
				if (indexes.size() == 0) indexes.push_back(UINT64_MAX);
			}
			return indexes;
		}

	};

}

#endif // AM_SCAN_KMP_H
