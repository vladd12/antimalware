#include "../am.scan.scanner.hpp"

namespace scan {
	// Function for worker threads
	void Scanner::Scan() {
		uint32_t batchSize = rb.GetBatchSize();
		uint32_t recordIndex = 0;
		std::size_t pos = 0;
		db::Record foundedRecord;
		// Main loop
		while (!tq.IsEmpty()) {
			DWORD dwWait = WaitForSingleObject(evSync, 1);
			if (dwWait == WAIT_TIMEOUT) {
				SyncScanning();
			}
			else if (dwWait == WAIT_OBJECT_0) {
				// Getting task from queue
				std::string task;
				if (!tq.IsEmpty()) task = tq.GetTask();
				int64_t dbSize = static_cast<int64_t>(dbfr.GetRecordCount());

				// If database file reader is closed try open it
				if (!dbfr.IsOpen()) {
					bool flag;
					do { flag = !dbfr.ReOpen(); } while (flag);
				}

				// Scanning file loop
				bool scanState = false;
				while (dbSize > 0) {
					uint32_t currentBatchSize = rb.ReadRecords(dbfr);
					// Scanning file
					scanState = ScanFile(task, currentBatchSize, recordIndex, pos);
					if (scanState) {
						db::Record& temp = rb.GetRecords()[recordIndex];
						foundedRecord.AllocName(temp.NameLength);
						foundedRecord.CopyName(temp.Name);
						foundedRecord.Signature = temp.Signature;
						break;
					}
					dbSize -= batchSize;
				}
				dbfr.SetToStart();

				// Send file status to UI Client and remove or replace file
				if (scanState) {
					SendFileStatus(task, scanState, pos, &foundedRecord);
					if (dAct == ipc::DetectAction::Remove) {
						// Remove file
						RemoveInfected(task);
					}
					else {
						// Replace file
						ReplaceInfected(task);
					}
				}
				else SendFileStatus(task, scanState);

			}
			else {
				// DEBUG
				std::cout << "Error waiting event: " << GetLastError() << '\n';
			}
		}
	}

	// Scanning file function for orker threads
	bool Scanner::ScanFile(std::string& file,
	  uint32_t& curBatchSize, uint32_t& rIndex, std::size_t& pos) {
		// Get section of code
		IMAGE_SECTION_HEADER cHeader;
		uint8_t* code = nullptr;
		try {
			cHeader = GetCodeSection(file.c_str());
			code = new uint8_t[cHeader.SizeOfRawData];
			// Open executable file
			std::ifstream scanned(file.c_str());
			scanned.seekg(cHeader.PointerToRawData, std::ios::beg);
			scanned.read(reinterpret_cast<char*>(code), cHeader.SizeOfRawData);
			scanned.close();
		}
		catch (...) {
			if (code != nullptr) delete[] code;
			return false;
		}

		// Get all records from batch
		auto records = rb.GetRecords();
		for (rIndex = 0; rIndex < curBatchSize; rIndex++) {
			// Search in range
			auto indexes = KMPMatch::IndexesOf(
				code + records[rIndex].Signature.Range.Start,
				cHeader.SizeOfRawData - records[rIndex].Signature.Range.End,
				records[rIndex].Signature.FirstBytes, 8);
			for (auto& index : indexes) {
				auto iHash = hash::GetSHA256(code + index, records[rIndex].Signature.Length);
				// Signature founded
				if (iHash == records[rIndex].Signature.Hash) {
					pos = index + static_cast<std::size_t>(cHeader.SizeOfRawData);
					if (code != nullptr) delete[] code;
					return true;
				}
			}
		}
		if (code != nullptr) delete[] code;
		return false;
	}

	// Sending status about executable file
	void Scanner::SendFileStatus(std::string& file, bool isInfected,
	  std::size_t pos, db::Record* rec) noexcept {
		ipc::FileStat fStat;
		memcpy_s(fStat.filePath, 512, file.c_str(), file.length() + 1);
		fStat.isInfected = isInfected;
		fStat.pos = pos;
		if (isInfected) {
			memcpy_s(fStat.signatureName, 256, rec->Name, rec->NameLength + 1);
		}
		ipc::MessageHolder msg;
		msg.Pack<ipc::FileStat>(fStat);
		msg.mType = ipc::MessageType::FileStatus;
		pipe.Send(msg);
	}

	// Replacing infected file to quarantine folder
	void Scanner::ReplaceInfected(std::string& oldFilePath) noexcept {
		char curProcPath[MAX_PATH];
		GetModuleFileNameA(NULL, curProcPath, sizeof(curProcPath));
		std::string newFilePath(curProcPath);
		newFilePath = newFilePath.substr(0, newFilePath.find_last_of("\\") + 1) + "qrntn\\";
		newFilePath = newFilePath + oldFilePath.substr(oldFilePath.find_last_of("\\") + 1);
		if (MoveFileA(oldFilePath.c_str(), newFilePath.c_str()) == FALSE) {
			// DEBUG
			//std::cout << "Error: " << GetLastError() << '\n';

			RemoveInfected(oldFilePath);
		}
		//std::cout << "\n\n" << newFilePath << '\n' << oldFilePath << '\n';
	}

	// Remove infected file
	void Scanner::RemoveInfected(std::string& file) noexcept {
		if (DeleteFileA(file.c_str()) == FALSE) {
			// Can't delete
			// DEBUG
			std::cout << "Can't delete, error: " << GetLastError() << '\n';
		}
		else {
			// Can delete
			// DEBUG
			std::cout << "Succeful deleting\n";
		}
	}

	// Waiting command for resume or stop scanning
	void Scanner::SyncScanning() noexcept {
		using namespace ipc;
		// Close reader thread in UI Client
		MessageHolder end(ipc::ScanningStat::EndedButton);
		end.mType = ipc::MessageType::ScanningStatus;
		pipe.Send(end);

		// Get command status
		auto msg = pipe.Read();
		if (msg.mType == MessageType::ScanningStatus) {
			auto stat = msg.Unpack<ScanningStat>();
			if (stat == ScanningStat::Resume) {
				// DEBUG
				std::cout << "Resume working\n";

				SetEvent(evSync);
			}
			else if (stat == ScanningStat::Stopped) {
				// DEBUG
				std::cout << "Stop working\n";

				tq.Clear();
				SetEvent(evSync);
			}
		}
	}

	// MultiThreadScanner constructor
	Scanner::Scanner(scan::TaskQueue& _tq, db::DBFileReader& _dbfr,
	  ipc::DetectAction& _dAct, HANDLE _evSync,
	  ipc::ServerPipe& _pipe) noexcept: tq(_tq), dbfr(_dbfr),
	  pipe(_pipe), rb(32), dAct(_dAct), evSync(_evSync) {
		Scan();
	}

}
