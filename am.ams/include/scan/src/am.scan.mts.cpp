#include "../am.scan.scanner.hpp"

namespace scan {
	// Function for worker threads
	void MultiThreadScanner::WorkerThread(MultiThreadScanner* _ms, bool* state) {
		std::string task;
		// Main loop
		while (_ms->isWorking) {
			// Wait signal from master thread
			WaitForSingleObject(_ms->evMStart, INFINITE);
			// Getting task from queue
			_ms->syncWorkers.lock();
			if (!_ms->_tq->IsEmpty()) {
				task = _ms->_tq->GetTask();
				*state = true;
				_ms->syncWorkers.unlock();

				// Scanning file loop
				bool scanState, finalState = false;
				// Wait signal from master thread
				WaitForSingleObject(_ms->evMRead1, INFINITE);
				while (_ms->dbSize > 0) {
					// Scanning file
					scanState = ScanFile(task, _ms->_rb, _ms->currentBatchSize);
					if (scanState) {
						// TODO: Send message to UI Client that file is bad
						std::cout << task << " is infected\n";
						finalState = true;
					}
					*state = true;
					// Wait signal from master thread
					WaitForSingleObject(_ms->evMRead2, INFINITE);
				}
				// TODO: Send message to UI Client that file is OK
				if (!finalState) {
					std::cout << task << " is Ok\n";
				}
			}
			// If no more tasks thread is passive
			else {
				_ms->syncWorkers.unlock();
				std::this_thread::yield();
				WaitForSingleObject(_ms->evMPassive, INFINITE);
				*state = true;
			}
		}
	}

	// TODO: Must return pointer to signature
	// Scanning file function for orker threads
	bool MultiThreadScanner::ScanFile(std::string& file, db::RecordBatch* rb, uint32_t& curBatchSize) {
		// Section of code
		auto cHeader(GetCodeSection(file.c_str()));
		auto code = new uint8_t[cHeader.SizeOfRawData];
		// Open executable file
		std::ifstream scanned(file.c_str());
		scanned.seekg(cHeader.PointerToRawData, std::ios::beg);
		scanned.read(reinterpret_cast<char*>(code), cHeader.SizeOfRawData);
		scanned.close();

		// Get all records from batch
		auto records(rb->GetRecords());
		for (uint32_t i = 0; i < curBatchSize; i++) {
			auto indexes(KMPMatch::IndexesOf(code, cHeader.SizeOfRawData, records[i].Signature.FirstBytes, 8));
			for (auto& index : indexes) {
				auto iHash(hash::GetSHA256(code + index, records[i].Signature.Length));
				// Signature founded
				if (iHash == records[i].Signature.Hash) {
					return true;
				}
			}
		}
		return false;
	}

	// Function for master thread
	void MultiThreadScanner::MasterThread(MultiThreadScanner* _ms) {
		std::size_t queueSize(0), currentWorkers(0), passive(0);
		// Main loop
		while (_ms->isWorking) {
			if (_ms->_tq->IsEmpty()) std::this_thread::yield();
			else {
				// Set start values
				queueSize = _ms->_tq->GetSize();
				if (queueSize >= _ms->numWorkers) {
					currentWorkers = _ms->numWorkers;
					passive = 0;
				}
				else {
					currentWorkers = queueSize;
					passive = _ms->numWorkers - queueSize;
				}

				// Set read event
				SetEvent(_ms->evMStart);
				// Wait workers
				WaitWorkers(_ms->rWorkersState, currentWorkers);
				ResetEvent(_ms->evMStart);

				// Read DB and RecordBatch info
				_ms->dbSize = static_cast<int64_t>(_ms->_dbfr->GetRecordCount());
				uint32_t batchSize(_ms->_rb->GetBatchSize());
				// Loop of reading batch from DB
				while (_ms->dbSize > 0) {
					_ms->currentBatchSize = _ms->_rb->ReadRecords(*_ms->_dbfr);
					SetEvent(_ms->evMRead1);
					ResetEvent(_ms->evMRead2);
					WaitWorkers(_ms->rWorkersState, currentWorkers);
					ResetEvent(_ms->evMRead1);
					_ms->dbSize -= batchSize;
					SetEvent(_ms->evMRead2);
				}
				_ms->_dbfr->SetToStart();

				// If we have threads in passive mode
				if (queueSize < _ms->numWorkers) {
					SetEvent(_ms->evMPassive);
					WaitWorkers(_ms->rWorkersState, passive);
					ResetEvent(_ms->evMPassive);
				}
			}
		}
	}

	// Check states of workers and wait them
	void MultiThreadScanner::WaitWorkers(std::deque<bool>& states, const std::size_t& num) {
		std::size_t i = 0;
		// Wait while [num] of workers will set state to true
		while (i != num) {
			for (auto& state : states) {
				if (state) i++;
			}
			if (i != num) {
				i = 0;
				std::this_thread::yield();
			}
		}
		// Reset state array
		for (auto& state : states) {
			state = false;
		}
	}

	// MultiThreadScanner constructor
	MultiThreadScanner::MultiThreadScanner(TaskQueue* tq, db::DBFileReader* dbfr, db::RecordBatch* rb) noexcept:
	numWorkers(std::thread::hardware_concurrency()), currentBatchSize(0), dbSize(0),
		isWorking(true), syncWorkers(), workers(), rWorkersState(numWorkers, false),
		evMStart(NULL), evMRead1(NULL), evMRead2(NULL), evMPassive(NULL),
		_tq(tq), _dbfr(dbfr), _rb(rb) {
		try {
			// Master thread's events
			evMStart = CreateEventA(NULL, TRUE, FALSE, "evMasterStart");
			evMRead1 = CreateEventA(NULL, TRUE, FALSE, "evMasterRead1");
			evMRead2 = CreateEventA(NULL, TRUE, FALSE, "evMasterRead2");
			evMPassive = CreateEventA(NULL, TRUE, FALSE, "evMasterPassive");
			if (evMStart == NULL || evMRead1 == NULL ||
				evMRead2 == NULL || evMPassive == NULL) throw;

			// Initial actions for worker threads
			workers.reserve(numWorkers);
			for (std::size_t i = 0; i < numWorkers; i++) {
				workers.push_back(std::thread(WorkerThread, this, &rWorkersState[i]));
				workers[i].detach();
			}

			// Initial master thread
			master = std::thread(MasterThread, this);
			master.detach();
		}
		catch (...) {
			isWorking = false;
		}
	}

	// Closing all threads
	void MultiThreadScanner::Shutdown() noexcept {
		isWorking = false;
	}

	// Join to all threads in scanner
	void MultiThreadScanner::JoinThreads() noexcept {
		for (std::size_t i = 0; i < numWorkers; i++) {
			if (workers[i].joinable()) {
				workers[i].join();
			}
		}
		if (master.joinable()) master.join();
	}

}
