#include "../am.scan.scanner.hpp"

namespace scan {
	// Function for worker threads
	void MultiThreadScanner::WorkerThread(MultiThreadScanner* _ms) {
		bool scanState = false;
		uint32_t batchSize(_ms->_rb->GetBatchSize());
		uint32_t recordIndex = 0;
		std::size_t pos = 0;
		db::Record foundedRecord;
		std::string task;
		// Main loop
		while (_ms->isWorking) {
			// Getting task from queue
			_ms->sync1.lock();
			if (!_ms->_tq->IsEmpty()) {
				try {
					task = _ms->_tq->GetTask();
					_ms->sync1.unlock();
				}
				catch (...) {
					_ms->sync1.unlock();
					continue;
				}

				_ms->sync2.lock();
				_ms->dbSize = static_cast<int64_t>(_ms->_dbfr->GetRecordCount());
				// If database file reader is closed try open it
				if (!_ms->_dbfr->IsOpen()) {
					bool flag;
					do {
						flag = !_ms->_dbfr->ReOpen();
					}
					while (flag);
				}
				// Scanning file loop
				while (_ms->dbSize > 0) {
					_ms->currentBatchSize = _ms->_rb->ReadRecords(*_ms->_dbfr);
					// Scanning file
					scanState = ScanFile(task, _ms->_rb, _ms->currentBatchSize, recordIndex, pos);
					if (scanState) {
						break;
						db::Record& temp = _ms->_rb->GetRecords()[recordIndex];
						foundedRecord.AllocName(temp.NameLength);
						foundedRecord.CopyName(temp.Name);
						foundedRecord.Signature = temp.Signature;
					}
					_ms->dbSize -= batchSize;
				}
				_ms->_dbfr->SetToStart();
				_ms->sync2.unlock();
				// Send file status to UI Client
				if (scanState) {
					SendFileStatus(task, scanState, _ms->_pipe, pos, &foundedRecord);
				}
				else SendFileStatus(task, scanState, _ms->_pipe);
			}
			// If no more tasks thread waits
			else {
				_ms->sync1.unlock();
				//std::this_thread::yield();
				Sleep(100);
			}
		}
	}

	// Scanning file function for orker threads
	bool MultiThreadScanner::ScanFile(std::string& file, db::RecordBatch* rb,
	  uint32_t& curBatchSize, uint32_t& rIndex, std::size_t& pos) {
		// Get section of code
		IMAGE_SECTION_HEADER cHeader;
		uint8_t* code = nullptr;
		try {
			cHeader = GetCodeSection(file.c_str());
			code = new uint8_t[cHeader.SizeOfRawData];
			// Open executable file
			std::ifstream scanned(file.c_str());
			scanned.seekg(cHeader.PointerToRawData, std::ios::beg);
			scanned.read(reinterpret_cast<char*>(code), cHeader.SizeOfRawData);
			scanned.close();
		}
		catch (...) {
			if (code != nullptr) delete[] code;
			return false;
		}

		// Get all records from batch
		auto records(rb->GetRecords());
		for (rIndex = 0; rIndex < curBatchSize; rIndex++) {
			auto indexes(KMPMatch::IndexesOf(code, cHeader.SizeOfRawData, records[rIndex].Signature.FirstBytes, 8));
			for (auto& index : indexes) {
				auto iHash(hash::GetSHA256(code + index, records[rIndex].Signature.Length));
				// Signature founded
				if (iHash == records[rIndex].Signature.Hash) {
					pos = index + static_cast<std::size_t>(cHeader.SizeOfRawData);
					return true;
				}
			}
		}
		return false;
	}

	// Sending status about executable file
	void MultiThreadScanner::SendFileStatus(std::string& file, bool isInfected,
	  ipc::ServerPipe* spipe, std::size_t pos, db::Record* rec) noexcept {
		ipc::FileStat fStat;
		memcpy_s(fStat.filePath, 512, file.c_str(), file.length() + 1);
		fStat.isInfected = isInfected;
		fStat.pos = pos;
		if (isInfected) {
			memcpy_s(fStat.signatureName, 256, rec->Name, rec->NameLength + 1);
		}
		ipc::MessageHolder msg;
		msg.Pack<ipc::FileStat>(fStat);
		msg.mType = ipc::MessageType::FileStatus;
		spipe->SendMsg(msg);
	}

	// MultiThreadScanner constructor
	MultiThreadScanner::MultiThreadScanner(TaskQueue* tq, db::DBFileReader* dbfr,
	  db::RecordBatch* rb, ipc::ServerPipe* pipe) noexcept:
	  numWorkers(std::thread::hardware_concurrency()), currentBatchSize(0),
	  dbSize(0), isWorking(true), workers(), _tq(tq), _dbfr(dbfr), _rb(rb),
	  _pipe(pipe)
	{
		try {
			// Initial actions for worker threads
			workers.reserve(numWorkers);
			for (std::size_t i = 0; i < numWorkers; i++) {
				workers.push_back(std::thread(WorkerThread, this));
				workers[i].detach();
			}
		}
		catch (...) {
			isWorking = false;
		}
	}

	// Closing all threads
	void MultiThreadScanner::Shutdown() noexcept {
		isWorking = false;
	}

	// Join to all threads in scanner
	void MultiThreadScanner::JoinThreads() noexcept {
		for (auto& worker : workers) {
			if (worker.joinable()) worker.join();
		}
	}

}
