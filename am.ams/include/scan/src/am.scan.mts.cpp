#include "../am.scan.scanner.hpp"

namespace scan {
	// Function for worker threads
	void MultiThreadScanner::WorkerThread(MultiThreadScanner* _ms) {
		std::string task;
		// Main loop
		while (_ms->isWorking) {
			// Getting task from queue
			_ms->sync1.lock();
			if (!_ms->_tq->IsEmpty()) {
				task = _ms->_tq->GetTask();
				_ms->sync1.unlock();

				// Scanning file loop
				bool scanState, finalState = false;
				uint32_t batchSize(_ms->_rb->GetBatchSize());
				_ms->sync2.lock();
				_ms->dbSize = static_cast<int64_t>(_ms->_dbfr->GetRecordCount());
				while (_ms->dbSize > 0) {
					_ms->currentBatchSize = _ms->_rb->ReadRecords(*_ms->_dbfr);
					// Scanning file
					scanState = ScanFile(task, _ms->_rb, _ms->currentBatchSize);
					if (scanState) {
						// TODO: Send message to UI Client that file is bad
						std::cout << task << " is infected\n";
						finalState = true;
					}
					_ms->dbSize -= batchSize;
				}
				_ms->_dbfr->SetToStart();
				_ms->sync2.unlock();
				// TODO: Send message to UI Client that file is OK
				if (!finalState) {
					std::cout << task << " is Ok\n";
				}
			}
			// If no more tasks thread waits
			else {
				_ms->sync1.unlock();
				std::this_thread::yield();
			}
		}
	}

	// TODO: Must return pointer to signature
	// Scanning file function for orker threads
	bool MultiThreadScanner::ScanFile(std::string& file, db::RecordBatch* rb, uint32_t& curBatchSize) {
		// Section of code
		auto cHeader(GetCodeSection(file.c_str()));
		auto code = new uint8_t[cHeader.SizeOfRawData];
		// Open executable file
		std::ifstream scanned(file.c_str());
		scanned.seekg(cHeader.PointerToRawData, std::ios::beg);
		scanned.read(reinterpret_cast<char*>(code), cHeader.SizeOfRawData);
		scanned.close();

		// Get all records from batch
		auto records(rb->GetRecords());
		for (uint32_t i = 0; i < curBatchSize; i++) {
			auto indexes(KMPMatch::IndexesOf(code, cHeader.SizeOfRawData, records[i].Signature.FirstBytes, 8));
			for (auto& index : indexes) {
				auto iHash(hash::GetSHA256(code + index, records[i].Signature.Length));
				// Signature founded
				if (iHash == records[i].Signature.Hash) {
					return true;
				}
			}
		}
		return false;
	}

	// MultiThreadScanner constructor
	MultiThreadScanner::MultiThreadScanner(TaskQueue* tq, db::DBFileReader* dbfr,
	  db::RecordBatch* rb) noexcept: numWorkers(std::thread::hardware_concurrency()),
	  currentBatchSize(0), dbSize(0), isWorking(true), workers(),
	  _tq(tq), _dbfr(dbfr), _rb(rb) {
		try {
			// Initial actions for worker threads
			workers.reserve(numWorkers);
			for (std::size_t i = 0; i < numWorkers; i++) {
				workers.push_back(std::thread(WorkerThread, this));
				workers[i].detach();
			}
		}
		catch (...) {
			isWorking = false;
		}
	}

	// Closing all threads
	void MultiThreadScanner::Shutdown() noexcept {
		isWorking = false;
	}

	// Join to all threads in scanner
	void MultiThreadScanner::JoinThreads() noexcept {
		for (auto& worker : workers) {
			if (worker.joinable()) worker.join();
		}
	}

}
