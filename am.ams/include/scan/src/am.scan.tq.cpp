#include "../am.scan.scanner.hpp"
#include <algorithm>
#include <sstream>

namespace scan {
	// Split string to substrings
	std::vector<std::string> TaskQueue::SplitString(const std::string& str, char delimeter) noexcept {
		std::vector<std::string> result;
		std::size_t numOfPaths = std::count(str.begin(), str.end(), delimeter) + 1;
		result.reserve(numOfPaths);
		std::stringstream ss(str);
		std::string item;
		while (std::getline(ss, item, delimeter)) {
			result.push_back(item);
		}
		return result;
	}

	// Scan path function
	void TaskQueue::ScanPath(std::string& path) noexcept {
		DWORD errState = ERROR_SUCCESS;
		// If path is a directory / folder
		if (IsDirectory(path.c_str())) {
			auto file = path;
			if (file[file.length() - 1] != '\\') file += "\\*.*";
			else file += "*.*";
			WIN32_FIND_DATAA        FindData;
			HANDLE hFind = FindFirstFileA(file.c_str(), &FindData);

			// Scan files in folder
			do {
				// If getting error
				if (hFind == INVALID_HANDLE_VALUE) {
					// DEBUG
					std::ofstream log("E:\\Test.txt", std::ios::app);
					log << "invalid handle\n";
					log.close();

					errState = GetLastError();
					continue;
				}
				// Except folders "." and ".."
				else if (!strcmp(FindData.cFileName, ".") || !strcmp(FindData.cFileName, "..")) {
					continue;
				}
				file = path + '\\' + FindData.cFileName;

				// DEBUG
				std::ofstream log("E:\\Test.txt", std::ios::app);
				log << file.c_str() << '\n';
				log.close();

				// If founded folder
				if (IsDirectory(FindData.dwFileAttributes)) {
					ScanPath(file);
				}
				// If founded file
				else CheckFile(file);
			} while (FindNextFileA(hFind, &FindData));
		}
		// If path is a file
		else CheckFile(path);
	}

	// Check is file executable
	void TaskQueue::CheckFile(std::string& file) noexcept {
		bool isExec;
		try { isExec = IsExecute(file.c_str()); }
		catch (DWORD&) { isExec = false; }
		if (isExec) tasks.push(file);
		else SendFileStatus(file);
	}

	// Sending status about non executable file
	void TaskQueue::SendFileStatus(std::string& file) noexcept {
		ipc::FileStat fStat;
		fStat.isInfected = false;
		fStat.pos = 0;
		memcpy_s(fStat.filePath, 512, file.c_str(), file.length() + 1);
		ipc::MessageHolder msg;
		msg.Pack<ipc::FileStat>(fStat);
		msg.mType = ipc::MessageType::FileStatus;
		spipe.SendMsg(msg);
	}

	// TaskQueue constructor
	TaskQueue::TaskQueue(ipc::ServerPipe& pipe)
	  noexcept: tasks(), spipe(pipe) { }

	// Parse unformated string to getting 
	// executable files in received paths
	void TaskQueue::PassUnformatedStr(std::string unformatted) {
		char delimeter = ';';
		if (unformatted[unformatted.length() - 1] == delimeter) {
			unformatted = unformatted.substr(0, unformatted.length() - 1);
		}

		auto formatted(SplitString(unformatted, delimeter));
		for (auto& path : formatted) {
			if (path.length() > 0) ScanPath(path);
		}
	}

	// Return size of queue of tasks
	std::size_t TaskQueue::GetSize() noexcept {
		std::size_t size = tasks.size();
		return size;
	}

	// Return false if queue is empty, else return true
	bool TaskQueue::IsEmpty() noexcept {
		return tasks.empty();
	}

	// Return string that contains path
	// to file that must be scanned
	std::string TaskQueue::GetTask() noexcept {
		std::string task(tasks.front());
		tasks.pop();
		return task;
	}


}
