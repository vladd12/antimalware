#include "../am.scan.scanner.hpp"
#include <algorithm>
#include <sstream>

namespace scan {
	// Split string to substrings
	std::vector<std::string> TaskQueue::SplitString(const std::string& str, char delimeter) noexcept {
		std::vector<std::string> result;
		std::size_t numOfPaths = std::count(str.begin(), str.end(), delimeter) + 1;
		result.reserve(numOfPaths);
		std::stringstream ss(str);
		std::string item;
		while (std::getline(ss, item, delimeter)) {
			result.push_back(item);
		}
		return result;
	}

	// Scan path function
	void TaskQueue::ScanPath(std::string& path) noexcept {
		if (!CheckSyncState()) return;
		DWORD errState = ERROR_SUCCESS;
		// If path is a directory / folder
		if (IsDirectory(path.c_str())) {
			auto file = path;
			if (file[file.length() - 1] != '\\') file += "\\*.*";
			else file += "*.*";
			WIN32_FIND_DATAA        FindData;
			HANDLE hFind = FindFirstFileA(file.c_str(), &FindData);

			// Scan files in folder
			do {
				// If getting error
				if (hFind == INVALID_HANDLE_VALUE) {
					errState = GetLastError();
					continue;
				}
				// Except folders "." and ".."
				else if (!strcmp(FindData.cFileName, ".") || !strcmp(FindData.cFileName, "..")) {
					continue;
				}
				file = path + '\\' + FindData.cFileName;
				// If founded folder
				if (IsDirectory(FindData.dwFileAttributes)) ScanPath(file);
				// If founded file
				else CheckFile(file);
			} while (FindNextFileA(hFind, &FindData) && CheckSyncState());
		}
		// If path is a file
		else CheckFile(path);
	}

	// Check is file executable
	void TaskQueue::CheckFile(std::string& file) noexcept {
		bool isExec;
		try { isExec = IsExecute(file.c_str()); }
		catch (DWORD&) { isExec = false; }
		if (isExec) {
			// DEBUG
			std::cout << file <<  " is executable\n";

			tasks.push(file);
		}
		// else SendFileStatus(file);
	}

	// Sending status about non executable file
	void TaskQueue::SendFileStatus(std::string& file) noexcept {
		ipc::FileStat fStat;
		fStat.isInfected = false;
		fStat.pos = 0;
		memcpy_s(fStat.filePath, 512, file.c_str(), file.length() + 1);
		ipc::MessageHolder msg(fStat);
		msg.mType = ipc::MessageType::FileStatus;
		pipe.Send(msg);
	}

	// ttt
	bool TaskQueue::CheckSyncState() noexcept {
		using namespace ipc;
		DWORD dwWait = WaitForSingleObject(evSync, 1);
		if (dwWait == WAIT_TIMEOUT) {
			if (isFirst) {
				// Close reader thread in UI Client
				MessageHolder end(ScanningStat::EndedButton);
				end.mType = MessageType::ScanningStatus;
				pipe.Send(end);

				// Get command status
				auto msg = pipe.Read();
				if (msg.mType == MessageType::ScanningStatus) {
					auto stat = msg.Unpack<ScanningStat>();
					if (stat == ScanningStat::Resume) {
						// DEBUG
						std::cout << "Resume working\n";

						SetEvent(evSync);
						return true;
					}
					else if (stat == ScanningStat::Pause) {
						// DEBUG
						std::cout << "Pause working\n";

						SetEvent(evSync);
						return true;
					}
					else {
						// DEBUG
						std::cout << "Stop working\n";

						isFirst = false;
						Clear();
						//SetEvent(evSync);
						return false;
					}
				}
				else return false;
			}
			else return false;
		}
		else if (dwWait == WAIT_OBJECT_0) {
			return true;
		}
		else return false;
	}

	// TaskQueue constructor
	TaskQueue::TaskQueue(ipc::ServerPipe& _pipe, HANDLE _evSync)
	  noexcept: tasks(), pipe(_pipe), evSync(_evSync), isFirst(true) { }

	// Parse unformated string to getting 
	// executable files in received paths
	void TaskQueue::PassUnformatedStr(std::string unformatted) {
		char delimeter = ';';
		if (unformatted[unformatted.length() - 1] == delimeter) {
			unformatted = unformatted.substr(0, unformatted.length() - 1);
		}

		auto formatted(SplitString(unformatted, delimeter));
		for (auto& path : formatted) {
			if (path.length() > 0) {
				if (!CheckSyncState()) break;
				ScanPath(path);
			}
		}
	}

	// Return size of queue of tasks
	std::size_t TaskQueue::GetSize() noexcept {
		std::size_t size = tasks.size();
		return size;
	}

	// Return false if queue is empty, else return true
	bool TaskQueue::IsEmpty() noexcept {
		return tasks.empty();
	}

	// Return string that contains path
	// to file that must be scanned
	std::string TaskQueue::GetTask() noexcept(false) {
		if (tasks.empty()) throw std::runtime_error("Queue is empty");
		else {
			std::string task = tasks.front();
			tasks.pop();
			return task;
		}
	}

	// Remove all tasks from task queue
	void TaskQueue::Clear() noexcept {
		while (!IsEmpty()) {
			tasks.pop();
		}
	}

}
