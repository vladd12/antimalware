#include "../include/am.slib.service.hpp"
#include <winsvc.h>

namespace slib {
	// Smart Pointer to Service Instant
	std::unique_ptr<Service> pService = nullptr;

	// Constructor
	Service::Service(LogTracer& _tracer, const std::wstring& _serviceName) noexcept :
		tracer(_tracer), serviceName(_serviceName), serviceStatus { NULL },
		serviceStatusHandle { NULL }
	{
		serviceStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
		serviceStatus.dwCurrentState = SERVICE_START_PENDING;
		serviceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN;
	}

	// Returns name of Service
	const std::wstring& Service::GetName() const noexcept {
		return serviceName;
	}

	// Starts the Service
	void Service::Start() noexcept(false) {
		// Register Service
		DWORD error;
		serviceStatus.dwCurrentState = SERVICE_START_PENDING;
		serviceStatusHandle = RegisterServiceCtrlHandlerW(serviceName.c_str(), (LPHANDLER_FUNCTION)ControlHandler);
		// If Register Failed
		if (serviceStatusHandle == (SERVICE_STATUS_HANDLE)0) {
			error = GetLastError();
			serviceStatus.dwCurrentState = SERVICE_STOPPED;
			serviceStatus.dwWin32ExitCode = error;
			NotifyState();
			tracer.Trace(TraceLevel::Error) << TEXT("Start service failed: error = ") << error << TEXT('\n');
			throw std::runtime_error("Register Service Failed");
		}

		// Init Service (abstract member)
		error = Init();
		// If Init Service Failed
		if (error) {
			serviceStatus.dwCurrentState = SERVICE_STOPPED;
			serviceStatus.dwWin32ExitCode = error;
			NotifyState();
			tracer.Trace(TraceLevel::Error) << TEXT("Init failed: error = ") << error << TEXT('\n');
			throw std::runtime_error("Init Service Failed");
		}

		// Start Service Work
		serviceStatus.dwCurrentState = SERVICE_RUNNING;
		NotifyState();
		while (serviceStatus.dwCurrentState == SERVICE_RUNNING) {
			DoWork();
		}
	}

	// Stops the Service
	void Service::Stop() noexcept {
		serviceStatus.dwCurrentState = SERVICE_STOP_PENDING;
		tracer.Trace(TraceLevel::Info) << TEXT("Stopping...\n");
		NotifyState();
		if (DoStop() == 0) {
			serviceStatus.dwWin32ExitCode = 0;
			serviceStatus.dwCurrentState = SERVICE_STOPPED;
			NotifyState();
			tracer.Trace(TraceLevel::Info) << TEXT("Stopped.\n");
		}
	}

	// Shutdown the Service
	void Service::Shutdown() noexcept {
		tracer.Trace(TraceLevel::Info) << TEXT("Shutting down...\n");
		if (DoStop() == 0) {
			serviceStatus.dwWin32ExitCode = 0;
			serviceStatus.dwCurrentState = SERVICE_STOPPED;
			NotifyState();
			tracer.Trace(TraceLevel::Info) << TEXT("Shutdown.\n");
		}
	}

	// Updates the Service Control Manager's status information for current Service
	void Service::NotifyState() noexcept {
		SetServiceStatus(serviceStatusHandle, &serviceStatus);
	}

	// Entry Point for Service
	extern "C" void WINAPI ServiceMain(DWORD argc, wchar_t** argv) noexcept {
		try {
			pService->Start();
		}
		catch (std::runtime_error&) {
			pService->Shutdown();
		}
	}

	// Service Control Handler
	extern "C" void WINAPI ControlHandler(DWORD request) noexcept {
		if (!pService) return;
		switch (request) {
		case SERVICE_CONTROL_STOP:
			pService->Stop();
			return;
		case SERVICE_CONTROL_SHUTDOWN:
			pService->Shutdown();
			return;
		}
		pService->NotifyState();
	}

	// Creating Service Table Entry and Init Service
	void InitService(std::shared_ptr<LogTracer>& tracer, IServiceFactory& serviceFactory) noexcept(false) {
		pService = serviceFactory.Create();
		std::wstring serviceName = pService->GetName();
		SERVICE_TABLE_ENTRYW ServiceTable[2];
		ServiceTable[0].lpServiceName = const_cast<LPWSTR>(serviceName.c_str());
		ServiceTable[0].lpServiceProc = (LPSERVICE_MAIN_FUNCTIONW)ServiceMain;
		ServiceTable[1].lpServiceName = NULL;
		ServiceTable[1].lpServiceProc = NULL;
		if (!StartServiceCtrlDispatcherW(ServiceTable)) {
			tracer->Trace(TraceLevel::Error) << TEXT("Error: StartServiceCtrlDispatcher: ") << GetLastError() << TEXT('\n');
			throw std::runtime_error("Service Control Dispatcher can\'t start the service");
		}
	}

}
