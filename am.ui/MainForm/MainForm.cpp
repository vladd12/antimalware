#include <string>
#include <Windows.h>
#include "MainForm.h"
#include "../InputForm/InputForm.h"

namespace am_ui {
	/* ------- Function prototypes ------ */
	// Sends message from client pipe
	void SendData(ipc::ClientPipe* client, ipc::MessageHolder& msg, System::Threading::Mutex^ locker);
	// Restarting main service
	void RealoadService(ipc::ClientPipe* pipe, trace::LogTracer* tracer);
	// t1
	void OutputFileStatus(ipc::FileStat& fStat, RichTextBox^ output);
	// t2
	void OutputScanningStatus(ipc::ScanningStat& scStat, RichTextBox^ output);
	/* --- End of function prototypes --- */

	// MainForm constructor
	MainForm::MainForm(void) {
		InitializeComponent();
		using System::Collections::Generic::List;
		using namespace System::Threading;
		using namespace core;
		// Set list of items for cbChsCtrlAction [comboBox]
		CtrlActions = gcnew List<ControlActionItem^>();
		CtrlActions->Add(gcnew ControlActionItem(ipc::ControlMessage::Start, "Start Service"));
		CtrlActions->Add(gcnew ControlActionItem(ipc::ControlMessage::Stop, "Stop Service"));
		CtrlActions->Add(gcnew ControlActionItem(ipc::ControlMessage::Shutdown, "Shutdown Service"));
		cbChsCtrlAction->DisplayMember = "ActionName";
		cbChsCtrlAction->ValueMember = "ActionType";
		cbChsCtrlAction->DataSource = CtrlActions;
		cbChsCtrlAction->SelectedIndex = 0;

		// Set list of items for cbChsDtctAction [comboBox]
		DtctActions = gcnew List<DetectionActionItem^>();
		DtctActions->Add(gcnew DetectionActionItem(ipc::DetectAction::Remove, "Remove files"));
		DtctActions->Add(gcnew DetectionActionItem(ipc::DetectAction::Replace, "Replace files to quarantine folder"));
		cbChsDtctAction->DisplayMember = "ActionName";
		cbChsDtctAction->ValueMember = "ActionType";
		cbChsDtctAction->DataSource = DtctActions;
		cbChsDtctAction->SelectedIndex = 0;

		// Create tracer and client pipes
		tracer = new trace::LogTracer();
		try {
			UIPipe = new ipc::ClientPipe(TEXT("UIPipe"), *tracer);
			// WDPipe = new ipc::ClientPipe(TEXT("WDUIPipe"), *tracer);
		}
		catch (std::runtime_error& ex) {
			std::string str(ex.what());
			RealoadService(UIPipe, tracer);
		}

		// Create control objects and threads
		StateRead = true;
		PipeLocker = gcnew System::Threading::Mutex();
		Reader = gcnew Thread(gcnew ParameterizedThreadStart(&ReaderProcess));
		Reader->Start(this);

	}

	// Destructor
	MainForm::~MainForm() {
		if (components) delete components;
		StateRead = false;
		Sleep(101);
		delete UIPipe;
		// delete WDPipe;
		delete tracer;
	}

	// Button send control message to service
	void MainForm::bCtrlAction_Click(System::Object^ sender, System::EventArgs^ e) {
		// Get ctrl msg from combo box and pack it in message holder
		ipc::ControlMessage action = safe_cast<core::ControlActionItem^>(cbChsCtrlAction->SelectedItem)->ActionType;
		ipc::MessageHolder buffer;
		buffer.Pack(action);
		buffer.mType = ipc::MessageType::CtrlMessage;
		// Send data or rerun service
		switch (action) {
		case ipc::ControlMessage::Start:
			lblText->Text = "Start";
			RealoadService(UIPipe, tracer);
			break;
		case ipc::ControlMessage::Stop:
			lblText->Text = "Stop";
			SendData(UIPipe, buffer, PipeLocker);
			break;
		case ipc::ControlMessage::Shutdown:
			lblText->Text = "Shutdown";
			SendData(UIPipe, buffer, PipeLocker);
			break;
		}
	}

	// Button for full scan was pressed
	void MainForm::btnFullScan_Click(System::Object^ sender, System::EventArgs^ e) {
		const DWORD dwSize = MAX_PATH;
		char szLogicalDrives[dwSize] = { 0 };
		std::string result = "";
		// Get all logical drives
		DWORD dwResult = GetLogicalDriveStringsA(dwSize, szLogicalDrives);
		if (dwResult > 0 && dwResult <= MAX_PATH) {
			char* szSingleDrive = szLogicalDrives;
			while (*szSingleDrive) {
				result += std::string(szSingleDrive) + ';';
				// Get the next drive
				szSingleDrive += strlen(szSingleDrive) + 1;
			}
		}
		ipc::TasksContainer tCont;
		tCont.dAction = GetDetectAction();
		memcpy_s(&tCont.unformString, 1016, result.c_str(), result.length() + 1);
		ipc::MessageHolder msg;
		msg.Pack(tCont);
		msg.mType = ipc::MessageType::Task;
		SendData(UIPipe, msg, PipeLocker);
	}

	// Button for fast scan was pressed
	void MainForm::btnFastScan_Click(System::Object^ sender, System::EventArgs^ e) {
		std::string task("C:\\Windows\\System32");
		ipc::TasksContainer tCont;
		tCont.dAction = GetDetectAction();
		memcpy_s(&tCont.unformString, 1016, task.c_str(), task.length() + 1);
		ipc::MessageHolder msg;
		msg.Pack(tCont);
		msg.mType = ipc::MessageType::Task;
		SendData(UIPipe, msg, PipeLocker);
	}

	// Sends message from client pipe
	void SendData(ipc::ClientPipe* client, ipc::MessageHolder& msg, System::Threading::Mutex^ locker) {
		locker->WaitOne();
		ipc::AuthStat clientStat;
		try {
			client->SendMsg(msg);
			clientStat = auth::AuthClient(*client);
		}
		catch (...) {
			delete client;
			client = new ipc::ClientPipe(TEXT("UIPipe"), trace::LogTracer());
		}
		locker->ReleaseMutex();
		if (clientStat == ipc::AuthStat::Disconnected) {
			MessageBox::Show("Произошла ошибка соединения!", "Ошибка",
			  MessageBoxButtons::OK, MessageBoxIcon::Error, MessageBoxDefaultButton::Button1);
		}
	}

	// Restarting main service
	void RealoadService(ipc::ClientPipe* pipe, trace::LogTracer* tracer) {
		system("am.ams.exe --run");
		delete pipe;
		pipe = new ipc::ClientPipe(TEXT("UIPipe"), *tracer);
	}

	// Function for reader thread
	void MainForm::ReaderProcess(Object^ obj) {
		auto mf = safe_cast<MainForm^>(obj);
		ipc::FileStat fStat;
		ipc::ScanningStat scStat;
		while (mf->StateRead) {
			if (mf->UIPipe->IsIncomingMsg()) {
				mf->PipeLocker->WaitOne();
				try {
					auto msg(mf->UIPipe->ReadMsg());
					switch (msg.mType) {
					case ipc::MessageType::FileStatus:
						fStat = msg.Unpack<ipc::FileStat>();
						OutputFileStatus(fStat, mf->tBoxOutput);
						break;
					case ipc::MessageType::ScanningStatus:
						scStat = msg.Unpack<ipc::ScanningStat>();
						break;
					}
				}
				catch (...) {

				}
				mf->PipeLocker->ReleaseMutex();
			}
			else Sleep(100);
		}
	}

	// t1
	void OutputFileStatus(ipc::FileStat& fStat, RichTextBox^ output) {
		if (fStat.isInfected) {
			output->Text = output->Text + gcnew String(fStat.filePath)
				+ " is infected. Malware's name: " + gcnew String(fStat.signatureName)
				+ ". Position in file: " + fStat.pos + "\n";
		}
		else {
			output->Text = output->Text + gcnew String(fStat.filePath) + " is clear.\n";
		}
	}

	// t2
	void OutputScanningStatus(ipc::ScanningStat& scStat, RichTextBox^ output) {

	}

	// t3
	ipc::DetectAction MainForm::GetDetectAction() {
		ipc::DetectAction action = safe_cast<core::DetectionActionItem^>(cbChsDtctAction->SelectedItem)->ActionType;
		return action;
	}

}
