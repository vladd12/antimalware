#include <thread>
#include <string>
#include "am.tests.ipc.hpp"
#include "am.auth.protocol.hpp"

namespace tests {
	using auth::MsgType;
	/* ----- Function prototypes ----- */
	// Function for thread with server pipe
	void ServerThreadFunc(const tchar*, trace::LogTracer*, auth::MsgType*, Behaviour*);
	// Function for thread with client pipe
	void ClientThreadFunc(const tchar*, trace::LogTracer*, Behaviour*, Behaviour*);
	/* --- End function prototypes --- */
	
	// Single process test kit
	void SingleProcTest(Tester& tester, const tchar* pipeName) {
		// Behaviours of ipc lib
		Behaviour authProto, correctMsg, clientStatus, serverStatus;
		auth::MsgType msgFromClient;

		// Creating tracer and threads for client and server pipes
		trace::LogTracer tracer("E:\\LogTests.txt");
		std::thread ServerThread(ServerThreadFunc, pipeName, &tracer, &msgFromClient, &serverStatus);
		Sleep(2);
		std::thread ClientThread(ClientThreadFunc, pipeName, &tracer, &authProto, &clientStatus);

		// Threads was closed
		ClientThread.join();
		ServerThread.join();

		// Data transportation status
		if (static_cast<MsgType>(msgFromClient) == MsgType::Start) {
			correctMsg = Behaviour::Expected;
		}
		else correctMsg = Behaviour::Unexpected;

		// Check all behaviours with tester
		tester.Test(authProto, Behaviour::Expected, "Correct Auth Protocol Work");
		tester.Test(correctMsg, Behaviour::Expected, "Correct Data Transportation");
		tester.Test(clientStatus, Behaviour::Expected, "Client Execution Status");
		tester.Test(serverStatus, Behaviour::Expected, "Server Execution Status");
	}

	// Wrappers test kit
	void WrappersTest(Tester& tester) {
		using namespace ipc;
		Behaviour test1, test2, test3, test4, test5;

		// TestWrapper classes
		const auto first = 2;
		const std::string second("abcd");
		TestWrapper int_wrap(first);
		TestWrapper str_wrap(second);

		// Testing int wrapper
		if (int_wrap.Cast<int>() == first) test1 = Behaviour::Expected;
		else test1 = Behaviour::Unexpected;
		
		// Testing std::string wrapper
		if (str_wrap.Cast<std::string>() == second) test2 = Behaviour::Expected;
		else test2 = Behaviour::Unexpected;

		// Wrapper class
		auto test_int = 1488;
		Wrapper wrap_int(test_int);

		// Testing correct std::type_info returning
		if (typeid(test_int) == wrap_int.GetTypeInfo()) test3 = Behaviour::Expected;
		else test3 = Behaviour::Unexpected;

		// Testing correct recast from byte array to requesting type
		if (wrap_int.Recast<int>() == test_int) test4 = Behaviour::Expected;
		else test4 = Behaviour::Unexpected;

		// Testing incorrect recast to requesting type
		try {
			unsigned int test_uint = wrap_int.Recast<unsigned int>();
			test5 = Behaviour::Unexpected;
		}
		catch (std::runtime_error&) {
			test5 = Behaviour::Expected;
		}

		// Check all behaviours with tester
		tester.Test(test1, Behaviour::Expected, "TestWrapper class correct casts stored int");
		tester.Test(test2, Behaviour::Expected, "TestWrapper class correct casts stored std::string");
		tester.Test(test3, Behaviour::Expected, "Wrapper class correct return stored std::type_info");
		tester.Test(test4, Behaviour::Expected, "Wrapper class correct casts stored int");
		tester.Test(test5, Behaviour::Expected, "Wrapper class correct react to incorrect request");
	}



	// Function for thread with server pipe
	void ServerThreadFunc(const tchar* pipeName, trace::LogTracer* ptrTracer,
		auth::MsgType* ptrMsgFromClient, Behaviour* ptrServerStatus)
	{
		// Server pipe working
		try {
			// Auth protocol working (server)
			ipc::ServerPipe owner(pipeName, *ptrTracer);
			// Body must be in loop: while (true) {} //
			owner.WaitIncomingMsg();
			*ptrMsgFromClient = owner.ReadMsg<MsgType>();
			auto responseStatus = auth::AuthServer(owner);
			if (responseStatus == auth::AuthStatus::Connected) {
				*ptrServerStatus = Behaviour::Expected;
			}
			else *ptrServerStatus = Behaviour::Unexpected;
		}
		catch (...) {
			*ptrServerStatus = Behaviour::Unexpected;
		}
	}

	// Function for thread with client pipe
	void ClientThreadFunc(const tchar* pipeName, trace::LogTracer* tracer,
		Behaviour* authProtoStatus, Behaviour* clientStatus)
	{
		// Client pipe working
		try {
			// Auth protocol working (client)
			ipc::ClientPipe client(pipeName, *tracer);
			client.SendMsg(MsgType::Start);
			auth::AuthStatus requestStatus = auth::AuthClient(client);
			if (requestStatus == auth::AuthStatus::Connected) {
				*authProtoStatus = Behaviour::Expected;
			}
			else *authProtoStatus = Behaviour::Unexpected;
			*clientStatus = Behaviour::Expected;
		}
		catch (...) {
			*clientStatus = Behaviour::Unexpected;
		}
	}

}
