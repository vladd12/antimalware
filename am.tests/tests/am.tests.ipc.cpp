#include <thread>
#include "am.tests.ipc.hpp"
#include "am.auth.protocol.hpp"

namespace tests {
	/* ----- Function prototypes ----- */
	// Function for thread with server pipe
	void ServerThreadFunc(const tchar*, trace::LogTracer*, DWORD*, Behaviour*);
	// Function for thread with client pipe
	void ClientThreadFunc(const tchar*, trace::LogTracer*, Behaviour*, Behaviour*);
	/* --- End function prototypes --- */

	// Message type enumeration
	enum MsgType {
		Start = 1,
		Stop = 2,
		Shutdown = 3
	};
	
	// Single process test kit
	void SingleProcTest(Tester& tester, const tchar* pipeName) {
		// Behaviours of ipc lib
		Behaviour authProto, correctMsg, clientStatus, serverStatus;
		DWORD msgFromClient;

		// Creating tracer and threads for client and server pipes
		trace::LogTracer tracer("E:\\Test.txt");
		std::thread ServerThread(ServerThreadFunc, pipeName, &tracer, &msgFromClient, &serverStatus);
		Sleep(2);
		std::thread ClientThread(ClientThreadFunc, pipeName, &tracer, &authProto, &clientStatus);

		// Threads was closed
		ClientThread.join();
		ServerThread.join();

		// Data transportation status
		if (static_cast<MsgType>(msgFromClient) == MsgType::Start) {
			correctMsg = Behaviour::Expected;
		}
		else correctMsg = Behaviour::Unexpected;

		// Check all behaviours with tester
		tester.Test(authProto, Behaviour::Expected, "Correct Auth Protocol Work");
		tester.Test(correctMsg, Behaviour::Expected, "Correct Data Transportation");
		tester.Test(clientStatus, Behaviour::Expected, "Client Execution Status");
		tester.Test(serverStatus, Behaviour::Expected, "Server Execution Status");
	}



	// Function for thread with server pipe
	void ServerThreadFunc(const tchar* pipeName, trace::LogTracer* ptrTracer,
		DWORD* ptrMsgFromClient, Behaviour* ptrServerStatus)
	{
		// Server pipe working
		try {
			// Auth protocol working (server)
			ipc::ServerPipe owner(pipeName, 1024, *ptrTracer);
			// Body must be in loop: while (true) {} //
			owner.WaitIncomingMsg();
			auth::AuthServer(owner, *ptrMsgFromClient);
			*ptrServerStatus = Behaviour::Expected;
		}
		catch (...) {
			*ptrServerStatus = Behaviour::Unexpected;
		}
	}

	// Function for thread with client pipe
	void ClientThreadFunc(const tchar* pipeName, trace::LogTracer* tracer,
		Behaviour* authProtoStatus, Behaviour* clientStatus)
	{
		// Client pipe working
		try {
			// Auth protocol working (client)
			ipc::ClientPipe client(pipeName, *tracer);
			DWORD requestStatus;
			client.SendMsg(MsgType::Start);
			auth::AuthClient(client, requestStatus);
			if (static_cast<auth::AuthStatus>(requestStatus) == auth::AuthStatus::Connected) {
				*authProtoStatus = Behaviour::Expected;
			}
			else *authProtoStatus = Behaviour::Unexpected;
			*clientStatus = Behaviour::Expected;
		}
		catch (...) {
			*clientStatus = Behaviour::Unexpected;
		}
	}

}
