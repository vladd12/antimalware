#include <thread>
#include <string>
#include "am.tests.ipc.hpp"
#include "am.auth.protocol.hpp"

namespace tests {
	using ipc::ControlMessage;
	/* ----- Function prototypes ----- */
	// Function for thread with server pipe
	void ServerThreadFunc(const tchar*, trace::LogTracer*, ipc::ControlMessage*, Behaviour*);
	// Function for thread with client pipe
	void ClientThreadFunc(const tchar*, trace::LogTracer*, Behaviour*, Behaviour*);
	/* --- End function prototypes --- */
	
	// Single process test kit
	void SingleProcTest(Tester& tester, const tchar* pipeName) {
		// Behaviours of ipc lib
		Behaviour authProto, correctMsg, clientStatus, serverStatus;
		ControlMessage msgFromClient;

		// Creating tracer and threads for client and server pipes
		trace::LogTracer tracer("E:\\LogTests.txt");
		std::thread ServerThread(ServerThreadFunc, pipeName, &tracer, &msgFromClient, &serverStatus);
		Sleep(2);
		std::thread ClientThread(ClientThreadFunc, pipeName, &tracer, &authProto, &clientStatus);

		// Threads was closed
		ClientThread.join();
		ServerThread.join();

		// Data transportation status
		if (msgFromClient == ControlMessage::Start) {
			correctMsg = Behaviour::Expected;
		}
		else correctMsg = Behaviour::Unexpected;

		// Check all behaviours with tester
		tester.Test(authProto, Behaviour::Expected, "Correct Auth Protocol Work");
		tester.Test(correctMsg, Behaviour::Expected, "Correct Data Transportation");
		tester.Test(clientStatus, Behaviour::Expected, "Client Execution Status");
		tester.Test(serverStatus, Behaviour::Expected, "Server Execution Status");
	}

	// Function for thread with server pipe
	void ServerThreadFunc(const tchar* pipeName, trace::LogTracer* ptrTracer,
		ipc::ControlMessage* ptrMsgFromClient, Behaviour* ptrServerStatus)
	{
		// Server pipe working
		try {
			// Auth protocol working (server)
			ipc::ServerPipe owner(pipeName, *ptrTracer);
			// Body must be in loop: while (true) {} //
			owner.WaitIncomingMsg();
			*ptrMsgFromClient = owner.ReadMsg().Unpack<ControlMessage>();
			auto responseStatus = auth::AuthServer(owner);
			if (responseStatus == ipc::AuthStat::Connected) {
				*ptrServerStatus = Behaviour::Expected;
			}
			else *ptrServerStatus = Behaviour::Unexpected;
		}
		catch (...) {
			*ptrServerStatus = Behaviour::Unexpected;
		}
	}

	// Function for thread with client pipe
	void ClientThreadFunc(const tchar* pipeName, trace::LogTracer* tracer,
		Behaviour* authProtoStatus, Behaviour* clientStatus)
	{
		// Client pipe working
		try {
			// Auth protocol working (client)
			ipc::ClientPipe client(pipeName, *tracer);
			ipc::MessageHolder buffer;
			buffer.Pack<ControlMessage>(ControlMessage::Start);
			client.SendMsg(buffer);
			ipc::AuthStat requestStatus = auth::AuthClient(client);
			if (requestStatus == ipc::AuthStat::Connected) {
				*authProtoStatus = Behaviour::Expected;
			}
			else *authProtoStatus = Behaviour::Unexpected;
			*clientStatus = Behaviour::Expected;
		}
		catch (...) {
			*clientStatus = Behaviour::Unexpected;
		}
	}

}
