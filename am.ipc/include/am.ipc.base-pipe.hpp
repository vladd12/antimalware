#ifndef AM_IPC_BASE_PIPE_H
#define AM_IPC_BASE_PIPE_H

#include <exception>
#include <memory>
#include <stdexcept>
#include "am.trace.log-tracer.hpp"
#include "am.ipc.wrapper.hpp"

namespace ipc {
	// Types definition
	typedef TCHAR tchar, _tchar;
	typedef unsigned int uint, _uint;
	using trace::LogTracer;
	using trace::TraceLevel;

	// Base Abstract Class for Pipes
	class IPC_LIB_API BasePipe {
	private:
		// Restriction copying of pipes
		explicit BasePipe() noexcept = delete;
		explicit BasePipe(const BasePipe& rhs) noexcept = delete;
		void operator=(const BasePipe& rhs) noexcept = delete;

	protected:
		HANDLE _hPipe;
		HANDLE _evRequest;
		HANDLE _evResponse;
		uint _bufSize;
		LogTracer&	_tracer;
		
		// Converts received from constructor name
		// to pipe API name and event pipe name
		void ConvertNames(tchar* pNameDest, tchar* eReqNameDest, tchar* eRespNameDest,
			const uint nameSize, const tchar* const nameSrc) noexcept;

		// Send message to pipe core function that use
		// override SendMsg functions in derived classes
		template<class Type>
		void SendMsgBase(Type& msg) noexcept(false);
		// void SendMsgBase(DWORD& msg) noexcept(false);

		// Read message from pipe core function that used by
		// override ReadMsg functions in derived classes
		template<class Type>
		Type ReadMsgBase() noexcept(false);

	public:
		explicit BasePipe(LogTracer& tracer) noexcept;
		virtual ~BasePipe() noexcept(false);

		// Send message to pipe abstract function
		template<class Type>
		void SendMsg(Type msg) noexcept(false) = 0;
		//virtual void SendMsg(DWORD msg) noexcept(false) = 0;

		// Read message from pipe abstract function
		template<class Type>
		Type ReadMsg() noexcept(false) = 0;
		//virtual DWORD GetMsg() noexcept(false) = 0;

		// Return bool value if pipe (owner process or 
		// another process) have incoming message
		virtual bool IsIncomingMsg() noexcept(false) = 0;
		
		// Pipe wait until get msg from
		// owner process/another process
		virtual void WaitIncomingMsg() noexcept(false) = 0;
	};

	// Send message to pipe core function that used by
	// override SendMsg functions in derived classes
	template<class Type>
	inline void BasePipe::SendMsgBase(Type& msg) noexcept(false) {
		// DebugInfo
		std::string strA(typeid(Type).name());
		_tracer.Trace(TraceLevel::Info) << std::wstring(strA.begin(), strA.end()).c_str() << TEXT('\n');

		Wrapper msgWrap(msg);
		DWORD cbReplyBytes = sizeof(msgWrap), cbWritten;
		BOOL fSuccess = WriteFile(_hPipe, &msgWrap, cbReplyBytes, &cbWritten, NULL);
		if (!fSuccess || cbReplyBytes != cbWritten) {
			_tracer.Trace(TraceLevel::Error) << TEXT("Failed writing data to pipe: ")
				<< GetLastError() << TEXT('\n');
			throw std::runtime_error("Failed write data to pipe");
		}
	}

	// Read message from pipe core function that used by
	// override ReadMsg functions in derived classes
	template<class Type>
	inline Type BasePipe::ReadMsgBase() noexcept(false) {
		const DWORD size = sizeof(Wrapper);
		DWORD cbBytesRead;
		uint8_t* buf = new uint8_t[size];
		BOOL fState = ReadFile(_hPipe, buf, size, &cbBytesRead, NULL);
		if (!fState || cbBytesRead != size) {
			delete[] buf;
			_tracer.Trace(TraceLevel::Error) << TEXT("Failed reading data from pipe: ")
				<< GetLastError() << TEXT('\n');
			throw std::runtime_error("Failed reading data from pipe");
		}
		else {
			Wrapper bufWrap(*reinterpret_cast<Wrapper*>(buf));
			delete[] buf;
			return bufWrap.Recast<Type>();
		}
	}

}

#endif // AM_IPC_BASE_PIPE_H
