#ifndef AM_IPC_WRAPPER_H
#define AM_IPC_WRAPPER_H

#include <cassert>
#include <memory>
#include <fstream>
#include <stdexcept>
#include <typeinfo>

namespace ipc {
	// Levels of response to client
	// about client's authorization status
	enum AuthStat {
		Connected = 1,
		Disconnected = 2
	};

	// Message type enumeration for
	// control services from pipe clients
	enum ControlMessage {
		Start = 1,
		Stop = 2,
		Shutdown = 3
	};

	// The action performed when
	// detecting the signature
	enum DetectAction {
		Remove = 1, 
		Replace = 2
	};

	// Scanning status enumeration
	enum ScanningStat {
		Request = 0,
		Active = 1,
		Pause = 2,
		Stopped = 3,
		Ended = 4
	};

	// Struct that contains detecting
	// action and unformatted string with
	// paths for scanning by scanner
	struct TasksContainer {
		DetectAction dAction;
		char unformString[1016];
	};

	// Struct that contain info about
	// scanned executable file
	struct FileStat {
		bool isInfected;
		std::size_t pos;
		char filePath[512];
		char signatureName[256];
	};

	// Struct that contains the
	// status of the action execution
	struct ActionStat {
		bool isCompleted;
	};

	// Struct that contains echo request
	struct EchoStat {
		bool isGood;
	};

	// Enumeration of message types
	enum MessageType {
		AuthStatus = 0,
		CtrlMessage = 1,
		Task = 2,
		FileStatus = 3,
		ActionStatus = 4,
		ScanningStatus = 5,
		EchoRequest = 6,
		None = 1000
	};

	// Constant for message size in message holder class
	const std::size_t msgSize = 1024;

	// Message holder class for exchange data between processes
	class MessageHolder {
	private:
		// Forced packing data to holder
		template <class Type>
		void PackHard(Type& data) {
			memset(&message, NULL, msgSize);
			memcpy_s(&message, msgSize, &data, sizeof(data));
		}

	public:
		MessageType mType;
		uint8_t message[msgSize];

		// Default constructor
		MessageHolder() noexcept {
			Clean();
		}

		// Constructor with params
		template <class Type>
		MessageHolder(Type data) noexcept {
			Pack(data);
		}

		// Extrating data from holder
		template <class Type> Type Unpack() noexcept {
			return *reinterpret_cast<Type*>(&message);
		}

		// Packing data to holder
		template <class Type>
		void Pack(Type data) noexcept {
			mType = None;
			PackHard(data);
		}

		// Packing data to holder
		template<> void Pack<>(AuthStat& aStat) {
			mType = AuthStatus;
			PackHard(aStat);
		}

		// Packing data to holder
		template<> void Pack<>(ControlMessage& cMsg) {
			mType = CtrlMessage;
			PackHard(cMsg);
		}

		// Packing data to holder
		template<> void Pack<>(TasksContainer& task) {
			mType = Task;
			PackHard(task);
		}

		// Packing data to holder
		template<> void Pack<>(FileStat& fStat) {
			mType = FileStatus;
			PackHard(fStat);
		}

		// Packing data to holder
		template<> void Pack<>(ActionStat& actStat) {
			mType = ActionStatus;
			PackHard(actStat);
		}

		// Packing data to holder
		template<> void Pack<>(ScanningStat& sStat) {
			mType = ScanningStatus;
			PackHard(sStat);
		}
		
		// Packing data to holder
		template<> void Pack<>(EchoStat& sStat) {
			mType = EchoRequest;
			PackHard(sStat);
		}

		// Cleans message holder
		void Clean() {
			mType = None;
			memset(&message, NULL, msgSize);
		}

	};

}

#endif // AM_IPC_WRAPPER_H
