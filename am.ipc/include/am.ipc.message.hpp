#ifndef AM_IPC_WRAPPER_H
#define AM_IPC_WRAPPER_H

#include <cassert>
#include <memory>
#include <fstream>
#include <stdexcept>
#include <typeinfo>

namespace ipc {
	/*
	// Wrapper class (useful)
	class Wrapper {
	private:
		static const std::size_t _BufSize = 1024;
		static const std::size_t _TypeInfoSize = sizeof(std::type_info);
		uint8_t _Buf[_BufSize];
		uint8_t _TypeInfo[_TypeInfoSize];

		// Core check types function
		bool _Check(const uint8_t* lhs,
			const uint8_t* rhs, std::size_t startIndex) const noexcept
		{
			bool isSame = true;
			for (std::size_t i = startIndex; i < _TypeInfoSize; i++) {
				if (lhs[i] != rhs[i]) {
					isSame = false;
					break;
				}
			}
			return isSame;
		}	

	public:
		// Delete default constructor
		Wrapper() = delete;

		// Constructor that takes stored data. Requirements:
		// size of stored data must be less than 1024 bytes
		template <class SavedType,
			std::enable_if_t<std::is_pod<SavedType>::value &&
			!(std::is_pointer<SavedType>::value), bool> = true>
		inline Wrapper(const SavedType& type) noexcept {
			const std::size_t _TypeSize = sizeof(type);
			static_assert(_TypeSize <= _BufSize, "Target type size larger then buffer size");
			memcpy_s(_Buf, _BufSize, &type, _TypeSize);
			memcpy_s(_TypeInfo, _TypeInfoSize, &typeid(type), _TypeInfoSize);
		}

		// Function for getting type info about stored data
		const std::type_info& GetTypeInfo() const noexcept {
			return *reinterpret_cast<const std::type_info*>(_TypeInfo);
		}

		// Function for comparing std::type_info that stored in uint8_t arrays
		const bool TypeInfoCmp(const std::type_info& _SavedType) const noexcept {
			// Copy std::type_info in binary raw array
			uint8_t _SavedTypeInfo[_TypeInfoSize];
			memcpy_s(_SavedTypeInfo, _TypeInfoSize, &_SavedType, _TypeInfoSize);

			// Debug info
			std::ofstream file("E:\\Test.txt", std::ios::app);
			const std::size_t _tName = reinterpret_cast<const std::type_info*>(_TypeInfo)->hash_code();
			const std::size_t sName = _SavedType.hash_code();

			// Check types in binary first try
			bool flag = _Check(_TypeInfo, _SavedTypeInfo, 0);
			// Check types second try
			if (!flag) flag = _Check(_TypeInfo, _SavedTypeInfo, 14);
			return flag;
		}

		// Cast stored data to original data type
		template<typename SavedType,
			std::enable_if_t<std::is_pod<SavedType>::value &&
			!(std::is_pointer<SavedType>::value), bool> = true>
		inline auto Recast() const noexcept(false) -> decltype(auto) {
			// Check types
			if (TypeInfoCmp(typeid(SavedType))) {
				SavedType* ptrData = const_cast<SavedType*>(reinterpret_cast<const SavedType*>(_Buf));
				return *ptrData;
			}
			else {
				throw std::runtime_error("Bad any cast");
			}
		}

	};
	*/

	// Levels of response to client
	// about client's authorization status
	enum AuthStat {
		Connected = 1,
		Disconnected = 2
	};

	// Message type enumeration for
	// control services from pipe clients
	enum ControlMessage {
		Start = 1,
		Stop = 2,
		Shutdown = 3
	};

	// The action performed when
	// detecting the signature
	enum DetectAction {
		Remove = 1, 
		Replace = 2
	};

	// Scanning status enumeration
	enum ScanningStat {
		Active = 1,
		Pause = 2,
		Ended = 3
	};

	// Struct that contains detecting
	// action and unformatted string with
	// paths for scanning by scanner
	struct TasksContainer {
		DetectAction dAction;
		char unformString[1016];
	};

	// Struct that contain info about
	// scanned executable file
	struct FileStat {
		bool isInfected;
		std::size_t pos;
		char filePath[512];
	};

	// Struct that contains the
	// status of the action execution
	struct ActionStat {
		bool isCompleted;
	};

	// Enumeration of message types
	enum MessageType {
		AuthStatus = 0,
		CtrlMessage = 1,
		Task = 2,
		FileStatus = 3,
		ActionStatus = 4,
		ScanningStatus = 5,
		None = 1000
	};

	// Message holder class for exchange data between processes
	class MessageHolder {
	private:
		// Extrating AuthStat from holder
		AuthStat ExtractAuthStat() {
			return *reinterpret_cast<AuthStat*>(&message);
		}

		// Extrating ControlMessage from holder
		ControlMessage ExtractCtrlMsg() {
			return *reinterpret_cast<ControlMessage*>(&message);
		}

		// Extrating TasksContainer from holder
		TasksContainer ExtractTaskCont() {
			return *reinterpret_cast<TasksContainer*>(&message);
		}

		// Extrating FileStat from holder
		FileStat ExtractFileStat() {
			return *reinterpret_cast<FileStat*>(&message);
		}

		// Extrating ActionStat from holder
		ActionStat ExtractActStat() {
			return *reinterpret_cast<ActionStat*>(&message);
		}

		// Extrating ScanningStat from holder
		ScanningStat ExtractScanStat() {
			return *reinterpret_cast<ScanningStat*>(&message);
		}

		// Forced packing data to holder
		template <class Type>
		void PackHard(Type& data) {
			memset(&message, NULL, sizeof(uint8_t) * 1024);
			memcpy_s(&message, sizeof(uint8_t) * 1024, &data, sizeof(data));
		}

	public:
		MessageType mType;
		uint8_t message[1024];

		// Extrating data from holder
		template <class Type> Type Unpack() {
			return *reinterpret_cast<Type*>(&message);
		}

		// Packing data to holder
		template <class Type>
		void Pack(Type data) {
			mType = None;
			PackHard(data);
		}

		// Packing data to holder
		template<> void Pack<>(AuthStat& aStat) {
			mType = AuthStatus;
			PackHard(aStat);
		}

		// Packing data to holder
		template<> void Pack<>(ControlMessage& cMsg) {
			mType = CtrlMessage;
			PackHard(cMsg);
		}

		// Packing data to holder
		template<> void Pack<>(TasksContainer& task) {
			mType = Task;
			PackHard(task);
		}

		// Packing data to holder
		template<> void Pack<>(FileStat& fStat) {
			mType = FileStatus;
			PackHard(fStat);
		}

		// Packing data to holder
		template<> void Pack<>(ActionStat& actStat) {
			mType = ActionStatus;
			PackHard(actStat);
		}

		// Packing data to holder
		template<> void Pack<>(ScanningStat& sStat) {
			mType = ScanningStatus;
			PackHard(sStat);
		}

	};

}

#endif // AM_IPC_WRAPPER_H
