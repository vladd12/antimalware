#ifndef AM_IPC_AUTH_PROTOCOL_H
#define AM_IPC_AUTH_PROTOCOL_H

#include "am.ipc.server-pipe.hpp"
#include "am.ipc.client-pipe.hpp"

namespace auth {
	using ipc::ServerPipe;
	using ipc::ClientPipe;
	
	// Levels of response to client
	// about clint's authorization status
	enum AuthStatus {
		Connected = 1,
		Disconnected = 2
	};

	// Message type enumeration for
	// control services from pipe clients
	enum MsgType {
		Start = 1,
		Stop = 2,
		Shutdown = 3
	};

	/*
	Usage:

	// Procedure 1
	ipc::NewPipe owner(TEXT("SomePipeName"), 32);
	DWORD incomMsg;
	while (true) {
		owner.WaitIncomingMsg();
		auth::AuthOwner(owner, incomMsg);
		if (incomMsg != 0 ) // Do something... // ;
		else // Throw exception or do something else... // ;
	}

	// Procedure 2
	enum MsgType { Start = 1, Stop = 2, Shutdown = 3 };
	ipc::ExistPipe client(TEXT("SomePipeName"));
	DWORD requestStatus;
	client.SendMsg(MsgType::Start);
	AuthClient(client, requestStatus);
	if (static_cast<auth::AuthStatus>(requestStatus) == AuthStatus::Connected) {
		// Do something... // ;
	}
	else // Do something else... // ;
	*/

	// Function that gives random number in range [start, end]
	IPC_LIB_API int GetRandNum(int start, int end) noexcept;

	// Function that calculates checksum via CRC16 algorithm
	IPC_LIB_API DWORD CRC16(uint8_t* addr, unsigned int length) noexcept;

	// Simple authorization algorithm for server pipe
	IPC_LIB_API AuthStatus AuthServer(ServerPipe& server) noexcept;

	// Simple authorization algorithm for client pipe
	IPC_LIB_API AuthStatus AuthClient(ClientPipe& client) noexcept;
	
}

#endif // AM_IPC_AUTH_PROTOCOL_H
