#ifndef AM_IPC_AUTH_PROTOCOL_H
#define AM_IPC_AUTH_PROTOCOL_H

#include "am.ipc.server-pipe.hpp"
#include "am.ipc.client-pipe.hpp"

namespace auth {
	using ipc::ServerPipe;
	using ipc::ClientPipe;
	
	// Levels of response to client
	// about clint's authorization status
	enum AuthStatus {
		Connected = 1,
		Disconnected = 2
	};

	// Message type enumeration
	enum MsgType {
		Start = 1,
		Stop = 2,
		Shutdown = 3
	};

	/*
	Usage:

	// Procedure 1
	ipc::NewPipe owner(TEXT("SomePipeName"), 32);
	DWORD incomMsg;
	while (true) {
		owner.WaitIncomingMsg();
		auth::AuthOwner(owner, incomMsg);
		if (incomMsg != 0 ) // Do something... // ;
		else // Throw exception or do something else... // ;
	}

	// Procedure 2
	enum MsgType { Start = 1, Stop = 2, Shutdown = 3 };
	ipc::ExistPipe client(TEXT("SomePipeName"));
	DWORD requestStatus;
	client.SendMsg(MsgType::Start);
	AuthClient(client, requestStatus);
	if (static_cast<auth::AuthStatus>(requestStatus) == AuthStatus::Connected) {
		// Do something... // ;
	}
	else // Do something else... // ;
	*/

	// Simple authorization algorithm for pipe server process
	IPC_LIB_API void AuthServer(ServerPipe& server, DWORD& request) noexcept;

	// Simple authorization algorithm for pipe client process/instance
	IPC_LIB_API void AuthClient(ClientPipe& client, DWORD& conStatus) noexcept;
	
}

#endif // AM_IPC_AUTH_PROTOCOL_H
