#ifndef AM_IPC_AUTH_PROTOCOL_H
#define AM_IPC_AUTH_PROTOCOL_H

#include "am.ipc.new-pipe.hpp"
#include "am.ipc.exist-pipe.hpp"

namespace auth {
	using ipc::tchar;
	using ipc::uint;
	
	// Levels of response to client
	// about clint's authorization status
	enum AuthStatus {
		Connected = 1,
		Disconnected = 2
	};

	/*
	Usage:

	// Procedure 1
	ipc::NewPipe owner(TEXT("SomePipeName"), 32);
	DWORD incomMsg;
	while (true) {
		owner.WaitIncomingMsg();
		auth::AuthOwner(owner, incomMsg);
		if (incomMsg != 0 ) // Do something... // ;
		else // Throw exception or do something else... // ;
	}

	// Procedure 2
	enum MsgType { Start = 1, Stop = 2, Shutdown = 3 };
	ipc::ExistPipe client(TEXT("SomePipeName"));
	DWORD requestStatus;
	client.SendMsg(MsgType::Start);
	AuthClient(client, requestStatus);
	if (static_cast<auth::AuthStatus>(requestStatus) == AuthStatus::Connected) {
		// Do something... // ;
	}
	else // Do something else... // ;
	*/

	// Simple authorization algorithm for pipe owner process
	IPC_LIB_API void AuthOwner(ipc::NewPipe&, DWORD&) noexcept;

	// Simple authorization algorithm for pipe client process/instance
	IPC_LIB_API void AuthClient(ipc::ExistPipe&, DWORD&) noexcept;
	
}

#endif // AM_IPC_AUTH_PROTOCOL_H
