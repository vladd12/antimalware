#ifndef AM_IPC_NEW_PIPE_H
#define AM_IPC_NEW_PIPE_H

#include "am.ipc.base-pipe.hpp"

namespace ipc {
	// Class of Server Pipe creating by owner process
	class IPC_LIB_API ServerPipe: public BasePipe {
	private:
		// Restriction copying of pipes
		explicit ServerPipe() noexcept = delete;
		explicit ServerPipe(const ServerPipe& rhs) noexcept = delete;
		void operator=(const ServerPipe& rhs) noexcept = delete;

		// Create event private function
		void CreateEv(HANDLE& evHandle, const tchar* const evName) noexcept(false);

	public:
		// Constructor
		explicit ServerPipe(const tchar* const pipeName,
			const uint bufSize, LogTracer& tracer) noexcept(false);

		// Destructor
		~ServerPipe() noexcept(false);

		// Wait connection from client pipe instance
		bool WaitConnection() noexcept;

		// Send message (response) from server pipe to client pipe
		template<class Type>
		void SendMsg(Type msg) noexcept(false);
		//void SendMsg(DWORD msg) noexcept(false) override;

		// Read message (request) from client
		template<class Type>
		Type GetMsg() noexcept(false);
		//DWORD GetMsg() noexcept(false) override;

		// ttt
		virtual void ActivatePipe() noexcept override;

		// Is are incoming message for server pipe?
		virtual bool IsIncomingMsg() noexcept(false) override;

		// Server pipe waits until a message is sent to him
		virtual void WaitIncomingMsg() noexcept(false) override;
	};

	// Send message (response) from server pipe to client pipe
	template<class Type>
	inline void ServerPipe::SendMsg(Type msg) noexcept(false) {
		// Using BasePipe::SendMsgBase(DWORD&)
		try {
			SendMsgBase(msg);
		}
		// Rethrow exception
		catch (std::runtime_error&) {
			throw;
		}
		// Activate event that informs that response has been sent 
		ActivatePipe();
	}

	// Read message (request) from client
	template<class Type>
	inline Type ServerPipe::GetMsg() noexcept(false) {
		const DWORD size = sizeof(Wrapper);
		DWORD cbBytesRead;
		uint8_t* buf = new uint8_t[size];
		BOOL fState = ReadFile(_hPipe, buf, size, &cbBytesRead, NULL);
		if (!fState || cbBytesRead != size) {
			delete[] buf;
			_tracer.Trace(TraceLevel::Error) << TEXT("Failed reading data from pipe: ")
				<< GetLastError() << TEXT('\n');
			throw std::runtime_error("Failed reading data from pipe");
		}
		else {
			// Request message has been read
			ResetEvent(_evRequest);
			Wrapper bufWrap(*reinterpret_cast<Wrapper*>(buf));
			delete[] buf;
			return bufWrap.Recast<Type>();
		}
	}

	// Fabric for Server Pipes
	IPC_LIB_API std::shared_ptr<ServerPipe>
		CreateServerPipe(const tchar* const pipeName,
		const uint bufSize, LogTracer& tracer) noexcept;

}

#endif // AM_IPC_NEW_PIPE_H
