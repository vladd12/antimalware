#ifndef AM_IPC_EXIST_PIPE_H
#define AM_IPC_EXIST_PIPE_H

#include "am.ipc.base-pipe.hpp"

namespace ipc {
	// Client Pipe class
	class IPC_LIB_API ClientPipe: public BasePipe {
	private:
		// Restriction copying of pipes
		explicit ClientPipe() noexcept = delete;
		explicit ClientPipe(const ClientPipe& rhs) noexcept = delete;
		void operator=(const ClientPipe& rhs) noexcept = delete;

		// Open existing pipe events and check errors
		void OpenEv(HANDLE& evHandle, const tchar* const evName) noexcept(false);

	public:
		// Constructor
		explicit ClientPipe(const tchar* const pipeName, trace::LogTracer& tracer) noexcept(false);

		// Send message (request) from pipe client
		template<class Type>
		void SendMsg(Type msg) noexcept(false);

		// Read message from pipe by another process/instance of pipe
		template<class Type>
		Type ReadMsg() noexcept(false);

		// Is are incoming message for another process/instance of pipe?
		virtual bool IsIncomingMsg() noexcept(false) override;

		// Client pipe waits until a message is sent to him
		virtual void WaitIncomingMsg() noexcept(false) override;

	};

	// Send message (request) from pipe client
	template<class Type>
	inline void ClientPipe::SendMsg(Type msg) noexcept(false) {
		// Using BasePipe::SendMsgBase(DWORD&)
		try {
			SendMsgBase(msg);
		}
		// Rethrow exception
		catch (std::runtime_error&) {
			throw;
		}
		// Activate event that informs that request has been sent 
		SetEvent(_evRequest);
	}

	// Read message from pipe by another process/instance of pipe
	template<class Type>
	inline Type ClientPipe::ReadMsg() noexcept(false) {
		// Using BasePipe::ReadMsgBase()
		Type msg;
		try {
			msg = ReadMsgBase<Type>();
		}
		// Rethrow exception
		catch (std::runtime_error&) {
			throw;
		}
		// Response message has been read
		ResetEvent(_evResponse);
		return msg;
	}

	// Fabric for Existing Pipes
	IPC_LIB_API std::shared_ptr<ClientPipe> CreateClientPipe(
		const tchar* const pipeName, trace::LogTracer& tracer) noexcept;

}

#endif // AM_IPC_EXIST_PIPE_H
