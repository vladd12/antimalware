#ifndef AM_IPC_WRAPPER_H
#define AM_IPC_WRAPPER_H

#include <cassert>
#include <memory>
#include <stdexcept>
#include <typeinfo>

namespace ipc {
	// Test Wrapper class (useless)
	class TestWrapper {
	public:
		// Base Holder class
		struct BaseHolder {
			// Virtual constructor
			virtual ~BaseHolder() noexcept = default;

			// Virtual destructor
			virtual const std::type_info& GetTypeInfo() const noexcept = 0;
		};

		// Holder class
		template <class Type>
		struct Holder : BaseHolder {
			// Stored object
			Type _any;

			// Constructor
			inline Holder(const Type& any) noexcept : _any(any) { }

			// Function for getting type info about stored object
			inline const std::type_info& GetTypeInfo() const noexcept {
				return typeid(Type);
			}
		};

		BaseHolder* _holder;

	public:
		// Constructor
		template <class Type>
		inline TestWrapper(const Type& container) noexcept :
			_holder(new Holder<Type>(container)) { }

		// Destructor
		~TestWrapper() {
			delete _holder;
		}

		// Cast stored data to original data type
		template<typename SavedType>
		SavedType Cast() const noexcept(false) {
			if (typeid(SavedType) == _holder->GetTypeInfo()) {
				Holder<SavedType>* holder = dynamic_cast<Holder<SavedType>*>(_holder);
				return holder->_any;
			}
			else throw std::runtime_error("Bad any cast");
		}

	};

	// Type Interface (useless)
	template <class _type>
	struct IType {
		typedef _type Type;
	};

	// Wrapper class (useful)
	class Wrapper {
	private:
		static const std::size_t _BufSize = 1024;
		static const std::size_t _TypeInfoSize = sizeof(std::type_info);
		uint8_t _Buf[_BufSize];
		uint8_t _TypeInfo[_TypeInfoSize];

		// Function for comparing std::type_info that stored in uint8_t arrays
		const bool _TypeInfoCmp(const uint8_t* first, const uint8_t* second) const noexcept {
			bool flag = true;
			for (std::size_t i = 0; i < _TypeInfoSize; i++) {
				if (first[i] != second[i]) {
					flag = false;
					break;
				}
			}
			return flag;
		}

	public:
		// Delete default constructor
		Wrapper() = delete;

		// Constructor that takes stored data. Requirements:
		// size of stored data must be less than 1024 bytes
		template <class Type,
			std::enable_if_t<std::is_pod<Type>::value &&
			!(std::is_pointer<Type>::value), bool> = true>
		inline Wrapper(const Type& type) noexcept {
			const std::size_t _TypeSize = sizeof(type);
			static_assert(_TypeSize <= _BufSize, "Target type size larger then buffer size");
			memcpy_s(_Buf, _BufSize, &type, _TypeSize);
			memcpy_s(_TypeInfo, _TypeInfoSize, &typeid(type), _TypeInfoSize);
		}

		// Function for getting type info about stored data
		const std::type_info& GetTypeInfo() const noexcept {
			return *reinterpret_cast<const std::type_info*>(_TypeInfo);
		}

		// Cast stored data to original data type
		template<typename SavedType,
			std::enable_if_t<std::is_pod<SavedType>::value &&
			!(std::is_pointer<SavedType>::value), bool> = true>
		inline auto Recast() const noexcept(false) -> decltype(auto) {
			uint8_t* _SavedTypeInfo = new uint8_t[_TypeInfoSize];
			memcpy_s(_SavedTypeInfo, _TypeInfoSize, &typeid(SavedType), _TypeInfoSize);

			const bool same = _TypeInfoCmp(_SavedTypeInfo, _TypeInfo);
			// Turn on assert for debug in runtime
			//assert(same && "Target type doesn't match the stored type");
			if (same) {
				delete[] _SavedTypeInfo;
				SavedType* ptrData = const_cast<SavedType*>(reinterpret_cast<const SavedType*>(_Buf));
				return *ptrData;
			}
			else {
				delete[] _SavedTypeInfo;
				throw std::runtime_error("Bad any cast");
			}
		}

	};

}

#endif // AM_IPC_WRAPPER_H
