#ifndef AM_IPC_WRAPPER_H
#define AM_IPC_WRAPPER_H

#include <cassert>
#include <memory>
#include <fstream>
#include <stdexcept>
#include <typeinfo>

namespace ipc {
	// Test Wrapper class (useless)
	class TestWrapper {
	public:
		// Base Holder class
		struct BaseHolder {
			// Virtual constructor
			virtual ~BaseHolder() noexcept = default;

			// Virtual destructor
			virtual const std::type_info& GetTypeInfo() const noexcept = 0;
		};

		// Holder class
		template <class Type>
		struct Holder : BaseHolder {
			// Stored object
			Type _any;

			// Constructor
			inline Holder(const Type& any) noexcept : _any(any) { }

			// Function for getting type info about stored object
			inline const std::type_info& GetTypeInfo() const noexcept {
				return typeid(Type);
			}
		};

		BaseHolder* _holder;

	public:
		// Constructor
		template <class Type>
		inline TestWrapper(const Type& container) noexcept :
			_holder(new Holder<Type>(container)) { }

		// Destructor
		~TestWrapper() {
			delete _holder;
		}

		// Cast stored data to original data type
		template<typename SavedType>
		SavedType Cast() const noexcept(false) {
			if (typeid(SavedType) == _holder->GetTypeInfo()) {
				Holder<SavedType>* holder = dynamic_cast<Holder<SavedType>*>(_holder);
				return holder->_any;
			}
			else throw std::runtime_error("Bad any cast");
		}

	};

	// Type Interface (useless)
	template <class _type>
	struct IType {
		typedef _type Type;
	};

	// Wrapper class (useful)
	class Wrapper {
	private:
		static const std::size_t _BufSize = 1024;
		static const std::size_t _TypeInfoSize = sizeof(std::type_info);
		uint8_t _Buf[_BufSize];
		uint8_t _TypeInfo[_TypeInfoSize];

		// Core check types function
		bool _Check(const uint8_t* lhs,
			const uint8_t* rhs, std::size_t startIndex) const noexcept
		{
			bool isSame = true;
			for (std::size_t i = startIndex; i < _TypeInfoSize; i++) {
				if (lhs[i] != rhs[i]) {
					isSame = false;
					break;
				}
			}
			return isSame;
		}	

	public:
		// Delete default constructor
		Wrapper() = delete;

		// Constructor that takes stored data. Requirements:
		// size of stored data must be less than 1024 bytes
		template <class SavedType,
			std::enable_if_t<std::is_pod<SavedType>::value &&
			!(std::is_pointer<SavedType>::value), bool> = true>
		inline Wrapper(const SavedType& type) noexcept {
			const std::size_t _TypeSize = sizeof(type);
			static_assert(_TypeSize <= _BufSize, "Target type size larger then buffer size");
			memcpy_s(_Buf, _BufSize, &type, _TypeSize);
			memcpy_s(_TypeInfo, _TypeInfoSize, &typeid(type), _TypeInfoSize);
		}

		// Function for getting type info about stored data
		const std::type_info& GetTypeInfo() const noexcept {
			return *reinterpret_cast<const std::type_info*>(_TypeInfo);
		}

		// Function for comparing std::type_info that stored in uint8_t arrays
		const bool TypeInfoCmp(const std::type_info& _SavedType) const noexcept {
			// Copy std::type_info in binary raw array
			uint8_t _SavedTypeInfo[_TypeInfoSize];
			memcpy_s(_SavedTypeInfo, _TypeInfoSize, &_SavedType, _TypeInfoSize);

			// Debug info
			std::ofstream file("E:\\Test.txt", std::ios::app);
			const std::size_t _tName = reinterpret_cast<const std::type_info*>(_TypeInfo)->hash_code();
			const std::size_t sName = _SavedType.hash_code();

			// Check types in binary first try
			bool flag = _Check(_TypeInfo, _SavedTypeInfo, 0);
			// Check types second try
			if (!flag) flag = _Check(_TypeInfo, _SavedTypeInfo, 14);
			return flag;
		}

		// Cast stored data to original data type
		template<typename SavedType,
			std::enable_if_t<std::is_pod<SavedType>::value &&
			!(std::is_pointer<SavedType>::value), bool> = true>
		inline auto Recast() const noexcept(false) -> decltype(auto) {
			// Check types
			if (TypeInfoCmp(typeid(SavedType))) {
				SavedType* ptrData = const_cast<SavedType*>(reinterpret_cast<const SavedType*>(_Buf));
				return *ptrData;
			}
			else {
				throw std::runtime_error("Bad any cast");
			}
		}

	};

}

#endif // AM_IPC_WRAPPER_H
