#include "../include/am.ipc.server-pipe.hpp"
#include <fstream>
#include <thread>

namespace ipc {
	// Constructor
	ServerPipe::ServerPipe(const tchar* const pipeName, const uint bufSize) noexcept(false) {
		// Create names for pipe and pipe events
		const uint nameSize = 256;
		tchar _pipeName[nameSize], _pipeEvReqName[nameSize], _pipeEvRespName[nameSize];
		ConvertNames(_pipeName, _pipeEvReqName, _pipeEvRespName, nameSize, pipeName);

		// DEBUG
		std::wofstream out("E:\\Test.txt", std::ios::app);
		out << L"NewPipe: " << _pipeName << L"\n\n";
		out.close();

		// Creation pipe's events
		try {
			CreateEv(_evRequest, _pipeEvReqName);
			CreateEv(_evResponse, _pipeEvRespName);
		}
		catch (std::runtime_error&) {
			// Rethrow if catch exepction
			throw;
		}

		// Creation pipe
		_bufSize = bufSize;
		_hPipe = CreateNamedPipe(_pipeName, PIPE_ACCESS_DUPLEX,
			PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,
			PIPE_UNLIMITED_INSTANCES, bufSize, bufSize, 0, NULL);
		// If creation pipe failed
		if (_hPipe == INVALID_HANDLE_VALUE) {
			throw std::runtime_error("Failed creation of pipe");
		}
		else if (GetLastError() == ERROR_ALREADY_EXISTS) {
			throw std::runtime_error("Pipe with this name already exist");
		}
		// If all is OK then wait connection
		else {
			if (!WaitConnection()) {
				throw std::runtime_error("Failed creation of pipe");
			}
		}
	}
	
	// Destructor
	ServerPipe::~ServerPipe() noexcept(false) {
		if (!(CloseHandle(_evRequest) && CloseHandle(_evResponse))) {
			throw std::runtime_error("Failed closing handles of pipe events");
		}
	}

	// Create event for pipe private function
	void ServerPipe::CreateEv(HANDLE& evHandle, const tchar* const evName) noexcept(false) {
		// Creating Security Descriptor for pipe event
		SECURITY_DESCRIPTOR sd = { 0 };
		DWORD fState = InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
		if (fState == NULL) {
			// GetLastError and Trace...
			throw std::runtime_error("Failed creation of Security Descriptor");
		}
		fState = SetSecurityDescriptorDacl(&sd, TRUE, NULL, FALSE);
		if (fState == NULL) {
			// GetLastError and Trace...
			throw std::runtime_error("Failed creation of Security Descriptor");
		}

		// Creating Security Attributes for pipe event
		SECURITY_ATTRIBUTES sa = { 0 };
		sa.nLength = sizeof(sa);
		sa.bInheritHandle = FALSE;
		sa.lpSecurityDescriptor = &sd;

		// Creation pipe event and get handle of it
		evHandle = CreateEvent(&sa, FALSE, FALSE, evName);

		// DEBUG
		std::wofstream out("E:\\Test.txt", std::ios::app);
		out << L"In NewPipe::CreateEv func: " << evName << L'\n'
			<< L"evHandle: " << evHandle << L'\n'
			<< L"GetLastError: " << GetLastError() << L"\n\n";
		out.close();

		// If creation pipe request event failed
		if (evHandle == NULL ||
			evHandle == (HANDLE)ERROR_INVALID_HANDLE ||
			evHandle == INVALID_HANDLE_VALUE)
		{
			throw std::runtime_error("Failed creation of pipe event");
		}
	}
	
	// Wait connection from client pipe instance
	bool ServerPipe::WaitConnection() {
		bool isConnect = ConnectNamedPipe(_hPipe, NULL) ?
			true : (GetLastError() == ERROR_PIPE_CONNECTED);
		return isConnect;
	}

	// Send message (response) from server pipe to client pipe
	void ServerPipe::SendMsg(DWORD msg) noexcept(false) {
		// Using BasePipe::SendMsgBase(DWORD&)
		try {
			SendMsgBase(msg);
		}
		// Rethrow exception
		catch (std::runtime_error&) {
			throw;
		}
		// Activate event that informs that response has been sent 
		SetEvent(_evResponse);
	}

	// Read message (request) from client
	DWORD ServerPipe::GetMsg(void) noexcept(false) {
		DWORD buf, cbBytesRead;
		BOOL fState = ReadFile(_hPipe, &buf, sizeof(DWORD), &cbBytesRead, NULL);
		if (!fState || cbBytesRead == 0) {
			throw std::runtime_error("Failed read data from pipe");
		}
		else if (cbBytesRead != sizeof(DWORD)) {
			throw std::runtime_error("Buffer and the received data from pipe have different sizes");
		}
		else {
			// Request message has been read
			ResetEvent(_evRequest);
			return buf;
		}
	}

	// Is are incoming message for server pipe?
	bool ServerPipe::IsIncomingMsg() noexcept(false) {
		DWORD dwWait = WaitForSingleObject(_evRequest, 1);
		if (dwWait == WAIT_FAILED) {
			throw std::runtime_error("Failed waiting for pipe request event");
		}
		else if (dwWait == WAIT_TIMEOUT) {
			return false;
		}
		else return true;
	}

	// Server pipe waits until a message is sent to him
	void ServerPipe::WaitIncomingMsg() noexcept(false) {
		// DEBUG
		std::wofstream out("E:\\Test.txt", std::ios::app);
		out << L"In NewPipe::WaitIncomingMsg func" << L'\n'
			<< L"Buf size of Pipe: " << _bufSize << L"\n\n";
		out.close();

		DWORD dwWait = WaitForSingleObject(_evRequest, INFINITE);
		if (dwWait == WAIT_OBJECT_0) return;
		else {
			std::runtime_error("Failed waiting for pipe request event");
		}
	}

	// Fabric for Server Pipes
	std::shared_ptr<ServerPipe> CreateServerPipe(const tchar* const pipeName, const uint bufSize) noexcept {
		return std::shared_ptr<ServerPipe>(new ServerPipe(pipeName, bufSize));
	}

}
