#include "../include/am.ipc.server-pipe.hpp"
#include <fstream>
#include <thread>

namespace ipc {
	using trace::LogTracer;
	using trace::TraceLevel;

	// Constructor
	ServerPipe::ServerPipe(const tchar* const pipeName, LogTracer& tracer)
		noexcept(false): BasePipe::BasePipe(tracer)
	{
		// Create names for pipe and pipe events
		const uint nameSize = 256;
		tchar _pipeName[nameSize], _pipeEvReqName[nameSize], _pipeEvRespName[nameSize];
		ConvertNames(_pipeName, _pipeEvReqName, _pipeEvRespName, nameSize, pipeName);
		// Info trace
		_tracer.Trace(TraceLevel::Info) << TEXT("ServerPipe: ") << _pipeName << TEXT('\n');

		// Creation pipe's events
		if (!CreateEv(_evRequest, _pipeEvReqName) ||
		  !CreateEv(_evResponse, _pipeEvRespName)) {
			throw std::runtime_error("Failed creating events");
		}

		// Creation pipe
		_hPipe = CreateNamedPipe(_pipeName, PIPE_ACCESS_DUPLEX,
			PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,
			PIPE_UNLIMITED_INSTANCES, sizeof(ipc::MessageHolder),
			sizeof(ipc::MessageHolder), 0, NULL);
		// If creation pipe failed
		if (_hPipe == INVALID_HANDLE_VALUE) {
			_tracer.Trace(TraceLevel::Error) << TEXT("Failed creating of pipe: ")
				<< GetLastError() << TEXT('\n');
			throw std::runtime_error("Failed creating of pipe");
		}
		else if (GetLastError() == ERROR_ALREADY_EXISTS) {
			_tracer.Trace(TraceLevel::Error) << TEXT("Pipe \"")
				<< _pipeName << TEXT("\" already exists\n");
			throw std::runtime_error("Pipe with this name already exist");
		}
		// If all is OK then wait connection
		else std::thread ConListener(WaitConnections, this);
	}
	
	// Destructor
	ServerPipe::~ServerPipe() noexcept {
		isConnect = false;
		if (_hPipe != INVALID_HANDLE_VALUE) Disconnect();
		if (_evRequest != INVALID_HANDLE_VALUE) CloseHandle(_evRequest);
		if (_evResponse != INVALID_HANDLE_VALUE) CloseHandle(_evResponse);
	}

	// Create event for pipe private function
	bool ServerPipe::CreateEv(HANDLE& evHandle, const tchar* const evName) noexcept {
		// Creating Security Descriptor for pipe event
		SECURITY_DESCRIPTOR sd = { 0 };
		DWORD fState = InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
		if (fState == NULL) {
			_tracer.Trace(TraceLevel::Error) << TEXT("Failed creating of Security Descriptor: ")
				<< GetLastError() << TEXT('\n');
			return false;
		}
		fState = SetSecurityDescriptorDacl(&sd, TRUE, NULL, FALSE);
		if (fState == NULL) {
			_tracer.Trace(TraceLevel::Error) << TEXT("Failed creating of Security Descriptor: ")
				<< GetLastError() << TEXT('\n');
			return false;
		}

		// Creating Security Attributes for pipe event
		SECURITY_ATTRIBUTES sa = { 0 };
		sa.nLength = sizeof(sa);
		sa.bInheritHandle = FALSE;
		sa.lpSecurityDescriptor = &sd;

		// Creating pipe event and get handle of it
		evHandle = CreateEvent(&sa, FALSE, FALSE, evName);
		// Info trace
		_tracer.Trace(TraceLevel::Info) << TEXT("ServerPipe::CreateEv\nEvent Name: ")
			<< evName << TEXT("\nEvent Handle: ") << evHandle 
			<< TEXT("\nGetLastError State: ") << GetLastError() << TEXT('\n');

		// If creation pipe request event failed
		if (evHandle == NULL || evHandle == (HANDLE)ERROR_INVALID_HANDLE || evHandle == INVALID_HANDLE_VALUE) {
			_tracer.Trace(TraceLevel::Error) << TEXT("Failed creating of pipe event: ")
				<< GetLastError() << TEXT('\n');
			return false;
		}
		else return true;
	}
	
	// Wait connection from client pipe instance
	void ServerPipe::WaitConnections(ServerPipe* pipe) noexcept {
		do {
			pipe->isConnect = ConnectNamedPipe(pipe->_hPipe, NULL) ?
				true : (GetLastError() == ERROR_PIPE_CONNECTED);
		} while (pipe->isConnect);
	}

	// Close connection with client
	bool ServerPipe::Disconnect() noexcept {
		FlushFileBuffers(_hPipe);
		bool disconStat = DisconnectNamedPipe(_hPipe) ? true : false;
		ResetEvent(_evRequest);
		ResetEvent(_evResponse);
		return disconStat;
	}

	// Check valid connection
	bool ServerPipe::IsValidConnection() noexcept {
		MessageHolder empty;
		return SendMsg(empty);
	}

	// Send message (response) from server pipe to client pipe
	bool ServerPipe::SendMsg(MessageHolder& msg) noexcept {
		// Using BasePipe::SendMsgBase
		bool sendingStatus(SendMsgBase(msg));
		if (sendingStatus) {
			SetEvent(_evResponse);
		}
		return sendingStatus;
	}

	// Read message (request) from client
	MessageHolder ServerPipe::ReadMsg() noexcept {
		// Using BasePipe::ReadMsgBase()
		MessageHolder msg = ReadMsgBase();
		// Request message has been read
		ResetEvent(_evRequest);
		return msg;
	}

	// Is are incoming message for server pipe?
	bool ServerPipe::IsIncomingMsg() noexcept(false) {
		DWORD dwWait = WaitForSingleObject(_evRequest, 1);
		if (dwWait == WAIT_FAILED) {
			_tracer.Trace(TraceLevel::Error) << TEXT("Failed waiting for pipe request event: ")
				<< GetLastError() << TEXT('\n');
			throw std::runtime_error("Failed waiting for pipe request event");
		}
		else if (dwWait == WAIT_TIMEOUT) {
			return false;
		}
		else return true;
	}

	// Server pipe waits until a message is sent to him
	void ServerPipe::WaitIncomingMsg() noexcept(false) {
		DWORD dwWait = WaitForSingleObject(_evRequest, INFINITE);
		if (dwWait == WAIT_OBJECT_0) return;
		else {
			_tracer.Trace(TraceLevel::Error) << TEXT("Failed waiting for pipe request event: ")
				<< GetLastError() << TEXT('\n');
			std::runtime_error("Failed waiting for pipe request event");
		}
	}

	// Fabric for Server Pipes
	std::shared_ptr<ServerPipe> CreateServerPipe(
		const tchar* const pipeName, LogTracer& tracer) noexcept
	{
		return std::shared_ptr<ServerPipe>(new ServerPipe(pipeName, tracer));
	}

}
