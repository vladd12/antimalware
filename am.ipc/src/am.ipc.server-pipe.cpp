#include "../include/am.ipc.server-pipe.hpp"

namespace ipc {
	// Default constructor
	ServerPipe::ServerPipe() noexcept: BasePipe() { }

	// Constructor with params
	ServerPipe::ServerPipe(const std::string& pipeName) noexcept(false) {
		if (!CreatePipe(pipeName)) {
			throw std::runtime_error("Failed creation of pipe");
		}
	}

	// Copying constructor
	ServerPipe::ServerPipe(const ServerPipe& rhs) noexcept {
		hPipe = rhs.hPipe;
	}

	// Overloading operator "="
	ServerPipe& ServerPipe::operator=(const ServerPipe& rhs) noexcept {
		hPipe = rhs.hPipe;
		return *this;
	}

	// Creating server pipe
	bool ServerPipe::CreatePipe(const std::string& pipeName) noexcept {
		std::string realName("\\\\.\\pipe\\" + pipeName);
		DWORD buffSize = sizeof(MessageHolder) * 16;
		hPipe = CreateNamedPipeA(realName.c_str(), PIPE_ACCESS_DUPLEX,
			PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,
			PIPE_UNLIMITED_INSTANCES, buffSize, buffSize, 0, NULL);
		if (hPipe == INVALID_HANDLE_VALUE) {
			errCode = GetLastError();
			return false;
		}
		else return true;
	}

	// Waiting connection
	bool ServerPipe::ServerPipe::WaitConnection() noexcept {
		bool isConnect = ConnectNamedPipe(hPipe, NULL) ?
			true : (GetLastError() == ERROR_PIPE_CONNECTED);
		return isConnect;
	}

	// Close connection with client
	bool ServerPipe::Disconnect() noexcept {
		FlushFileBuffers(hPipe);
		bool state = DisconnectNamedPipe(hPipe) ? true : false;
		return state;
	}

}
