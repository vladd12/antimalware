#include "../include/am.ipc.new-pipe.hpp"
#include <thread>

namespace ipc {
	// Constructor
	NewPipe::NewPipe(const tchar* const pipeName, const uint bufSize)
		noexcept(false): _listenFlag(true)
	{
		// Create names for pipe and pipe events
		const uint nameSize = 256;
		tchar _pipeName[nameSize], _pipeEvReqName[nameSize], _pipeEvRespName[nameSize];
		ConvertNames(_pipeName, _pipeEvReqName, _pipeEvRespName, nameSize, pipeName);

		// Creation pipe's events
		try {
			CreateEv(_evRequest, _pipeEvReqName);
			CreateEv(_evResponse, _pipeEvRespName);
		}
		catch (std::runtime_error&) {
			// Rethrow if catch exepction
			throw;
		}

		// Creation pipe
		_bufSize = bufSize;
		_hPipe = CreateNamedPipe(_pipeName, PIPE_ACCESS_DUPLEX,
			PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,
			PIPE_UNLIMITED_INSTANCES, bufSize, bufSize, 0, NULL);
		// If creation pipe failed
		if (_hPipe == INVALID_HANDLE_VALUE) {
			throw std::runtime_error("Failed creation of pipe");
		}
		// If all is OK
		else ListenCons();
	}
	
	// Destructor
	NewPipe::~NewPipe() noexcept(false) {
		if (!(CloseHandle(_evRequest) && CloseHandle(_evResponse))) {
			throw std::runtime_error("Failed closing handles of pipe events");
		}
	}

	// Create event private function
	void NewPipe::CreateEv(HANDLE& evHandle, const tchar* const evName) noexcept(false) {
		// Creation pipe request event
		evHandle = CreateEvent(NULL, FALSE, FALSE, evName);
		// If creation pipe request event failed
		if (_evRequest == NULL ||
			_evRequest == (HANDLE)ERROR_INVALID_HANDLE ||
			_evRequest == INVALID_HANDLE_VALUE)
		{
			throw std::runtime_error("Failed creation of pipe event");
		}
	}

	// Pipe is listen requests for read/write
	void NewPipe::ListenCons() noexcept {
		std::thread WaitConThr(WaitConnection, this);
		WaitConThr.detach();
	}

	// Pipe stop listening requests for read/write (except the last one)
	void NewPipe::StopListenCons() noexcept {
		_listenFlag = false;
	}

	// Function for a detached thread listening to one connection
	void NewPipe::WaitConnection(NewPipe* obj) noexcept {
		while (obj->_listenFlag) {
			BOOL isConnect = ConnectNamedPipe(obj->_hPipe, NULL);
			if (!isConnect) Sleep(100);
			else obj->_listenFlag = false;
		}
	}

	// Send message (response) from owner pipe class
	void NewPipe::SendMsg(DWORD msg) noexcept(false) {
		// Using BasePipe::SendMsgBase(DWORD&)
		try {
			SendMsgBase(msg);
		}
		// Rethrow exception
		catch (std::runtime_error&) {
			throw;
		}
		// Activate event that informs that response has been sent 
		SetEvent(_evResponse);
	}

	// Read message (request) from pipe by owner
	DWORD NewPipe::GetMsg(void) noexcept(false) {
		DWORD buf, cbBytesRead;
		BOOL fState = ReadFile(_hPipe, &buf, sizeof(DWORD), &cbBytesRead, NULL);
		if (!fState || cbBytesRead == 0) {
			throw std::runtime_error("Failed read data from pipe");
		}
		else if (cbBytesRead != sizeof(DWORD)) {
			throw std::runtime_error("Buffer and the received data from pipe have different sizes");
		}
		else {
			// Request message has been read
			ResetEvent(_evRequest);
			return buf;
		}
	}

	// Is are incoming message for pipe owner?
	bool NewPipe::IsIncomingMsg() noexcept(false) {
		DWORD dwWait = WaitForSingleObject(_evRequest, 1);
		if (dwWait == WAIT_FAILED) {
			throw std::runtime_error("");
		}
		else if (dwWait == WAIT_TIMEOUT) {
			return false;
		}
		else return true;
	}

	// Fabric for New Pipes
	std::shared_ptr<NewPipe> CreateNewPipe(const tchar* const pipeName, const uint bufSize) noexcept {
		return std::shared_ptr<NewPipe>(new NewPipe(pipeName, bufSize));
	}

}
