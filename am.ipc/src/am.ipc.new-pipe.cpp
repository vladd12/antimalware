#include "../include/am.ipc.new-pipe.hpp"
#include <thread>

namespace ipc {
	// Constructor
	NewPipe::NewPipe(const tchar* const pipeName, const uint bufSize) throw (...) : listenFlag(true) {
		// Creation pipe
		_bufSize = bufSize;
		_hPipe = CreateNamedPipe(pipeName, PIPE_ACCESS_DUPLEX,
			PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,
			PIPE_UNLIMITED_INSTANCES, bufSize, bufSize, 0, NULL);
		// If creation failed
		if (_hPipe == INVALID_HANDLE_VALUE) {
			throw std::runtime_error("Failed creation of pipe");
		}
		// Another case
		else ListenCons();
	}

	// Read message from Pipe by owner proccess
	DWORD NewPipe::GetMsg(void) throw (...) {
		DWORD buf, cbBytesRead;
		BOOL fState = ReadFile(_hPipe, &buf, sizeof(DWORD), &cbBytesRead, NULL);
		if (!fState || cbBytesRead == 0) {
			throw std::runtime_error("Failed read data from pipe");
		}
		else if (cbBytesRead != sizeof(DWORD)) {
			throw std::runtime_error("Buffer and the received data from pipe have different sizes");
		}
		else return buf;
	}

	// Pipe is listen requests for read/write
	void NewPipe::ListenCons() noexcept {
		std::thread WaitConThr(WaitConnection, this);
		WaitConThr.detach();
	}

	// Pipe stop listening requests for read/write (except the last one)
	void NewPipe::StopListenCons() noexcept {
		listenFlag = false;
	}

	// Function for a detached thread listening to connections 
	void NewPipe::WaitConnection(NewPipe* obj) noexcept {
		while (obj->listenFlag) {
			BOOL fState = ConnectNamedPipe(obj->_hPipe, NULL);
			if (fState == FALSE) Sleep(100);
		}
	}

	// Fabric for New Pipes
	std::shared_ptr<NewPipe> CreateNewPipe(const tchar* const pipeName, const uint bufSize) {
		return std::shared_ptr<NewPipe>(new NewPipe(pipeName, bufSize));
	}

}