#include "../include/am.ipc.new-pipe.hpp"

using namespace IPC;

// Constructor
NewPipe::NewPipe(const tchar* const pipeName, const uint bufSize) throw (std::runtime_error) {
	// Creation pipe
	_bufSize = bufSize;
	_hPipe = CreateNamedPipe(pipeName, PIPE_ACCESS_DUPLEX,
		PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,
		PIPE_UNLIMITED_INSTANCES, bufSize, bufSize, 0, NULL);
	// If creation failed
	if (_hPipe == INVALID_HANDLE_VALUE) {
		throw std::runtime_error("Failed creation of pipe");
	}
}

// Destructor
NewPipe::~NewPipe() throw (std::runtime_error) {
	if (CloseHandle(_hPipe) != TRUE) {
		throw std::runtime_error("Failed closing handle of pipe");
	}
}

// Read message from Pipe by owner
DWORD IPC::NewPipe::GetMsg(void) throw (std::runtime_error) {
	DWORD buf, cbBytesRead;
	BOOL fState = ConnectNamedPipe(_hPipe, NULL);
	if (fState == TRUE) {
		fState = ReadFile(_hPipe, &buf, sizeof(DWORD), &cbBytesRead, NULL);
		if (!fState || cbBytesRead == 0) {
			throw std::runtime_error("Failed read data from pipe");
		}
		else if (cbBytesRead != sizeof(DWORD)) {
			throw std::runtime_error("Buffer and the received data from pipe have different sizes");
		}
		else return buf;
	}
	else throw std::runtime_error("Failed connecting to pipe");
}

// Fabric for Pipes
std::shared_ptr<NewPipe> CreateNewPipe(const tchar* const pipeName, const uint& bufSize) {
	return std::make_shared<NewPipe>(pipeName, bufSize);
}
