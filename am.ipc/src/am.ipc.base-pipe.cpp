#include "../include/am.ipc.base-pipe.hpp"

namespace ipc {
	using trace::LogTracer;
	using trace::TraceLevel;

	// Constructor
	BasePipe::BasePipe(LogTracer& tracer) noexcept:
		_hPipe(INVALID_HANDLE_VALUE), _evRequest(NULL),
		_evResponse(NULL), _tracer(tracer) { }

	// Destructor
	BasePipe::~BasePipe() noexcept {
		if (!CloseHandle(_hPipe)) {
			_tracer.Trace(TraceLevel::Error) << TEXT("Failed closing pipe handle: ")
				<< GetLastError() << TEXT('\n');
		}
	}

	// Converts received from constructor name
	// to pipe API name and event pipe name
	void BasePipe::ConvertNames(tchar* pNameDest, tchar* eReqNameDest,
		tchar* eRespNameDest, const uint nameSize, const tchar* const nameSrc) noexcept
	{
		pNameDest[0] = TEXT('\0');
		eReqNameDest[0] = TEXT('\0');
		eRespNameDest[0] = TEXT('\0');
		_tcscat_s(pNameDest, nameSize, TEXT("\\\\.\\pipe\\"));
		_tcscat_s(pNameDest, nameSize, nameSrc);
		_tcscat_s(eReqNameDest, nameSize, TEXT("Global\\evRequest"));
		_tcscat_s(eReqNameDest, nameSize, nameSrc);
		_tcscat_s(eRespNameDest, nameSize, TEXT("Global\\evResponse"));
		_tcscat_s(eRespNameDest, nameSize, nameSrc);
	}

	// Send message to pipe core function that used by
	// override SendMsg functions in derived classes
	bool BasePipe::SendMsgBase(MessageHolder& msg) noexcept {
		DWORD cbReplyBytes = sizeof(MessageHolder), cbWritten;
		BOOL fSuccess = WriteFile(_hPipe, &msg, cbReplyBytes, &cbWritten, NULL);
		if (!fSuccess || cbReplyBytes != cbWritten) {
			_tracer.Trace(trace::TraceLevel::Error)
				<< TEXT("Failed writing data to pipe: ")
				<< GetLastError() << TEXT('\n');
			return false;
		}
		else return true;
	}

	// Read message from pipe core function that used by
	// override ReadMsg functions in derived classes
	MessageHolder BasePipe::ReadMsgBase() noexcept {
		MessageHolder msg;
		DWORD size = sizeof(msg), cbBytesRead;
		BOOL fState = ReadFile(_hPipe, &msg, size, &cbBytesRead, NULL);
		if (!fState || cbBytesRead != size) {
			_tracer.Trace(trace::TraceLevel::Error) << TEXT("Failed reading data from pipe: ")
				<< GetLastError() << TEXT('\n');
			msg.Clean();
		}
		return msg;
	}

}
