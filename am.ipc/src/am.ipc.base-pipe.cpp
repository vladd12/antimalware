#include "../include/am.ipc.base-pipe.hpp"

namespace ipc {
	using trace::LogTracer;
	using trace::TraceLevel;

	// Constructor
	BasePipe::BasePipe(LogTracer& tracer) noexcept:
		_hPipe(INVALID_HANDLE_VALUE), _evRequest(NULL),
		_evResponse(NULL), _bufSize(sizeof(Wrapper)), _tracer(tracer) { }

	// Destructor
	BasePipe::~BasePipe() noexcept(false) {
		if (!CloseHandle(_hPipe)) {
			_tracer.Trace(TraceLevel::Error) << TEXT("Failed closing pipe handle: ")
				<< GetLastError() << TEXT('\n');
			throw std::runtime_error("Failed closing pipe handle");
		}
	}

	// Converts received from constructor name
	// to pipe API name and event pipe name
	void BasePipe::ConvertNames(tchar* pNameDest, tchar* eReqNameDest,
		tchar* eRespNameDest, const uint nameSize, const tchar* const nameSrc) noexcept
	{
		pNameDest[0] = TEXT('\0');
		eReqNameDest[0] = TEXT('\0');
		eRespNameDest[0] = TEXT('\0');
		_tcscat_s(pNameDest, nameSize, TEXT("\\\\.\\pipe\\"));
		_tcscat_s(pNameDest, nameSize, nameSrc);
		_tcscat_s(eReqNameDest, nameSize, TEXT("Global\\evRequest"));
		_tcscat_s(eReqNameDest, nameSize, nameSrc);
		_tcscat_s(eRespNameDest, nameSize, TEXT("Global\\evResponse"));
		_tcscat_s(eRespNameDest, nameSize, nameSrc);
	}

}
