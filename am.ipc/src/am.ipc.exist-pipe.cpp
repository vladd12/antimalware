#include "../include/am.ipc.exist-pipe.hpp"

using namespace IPC;

// Constructor
ExistPipe::ExistPipe(const tchar* const pipeName) throw(std::runtime_error) {
	_hPipe = CreateFile(pipeName,
		GENERIC_READ | GENERIC_WRITE, 0,
		NULL, OPEN_EXISTING, 0, NULL);
	if (_hPipe == INVALID_HANDLE_VALUE) {
		throw std::runtime_error("Failed creation of pipe");
	}
}

// Destructor
ExistPipe::~ExistPipe() throw(std::runtime_error) {
	if (CloseHandle(_hPipe) != TRUE) {
		throw std::runtime_error("Failed closing handle of pipe");
	}
}

// Read message from Pipe by client proccess
DWORD ExistPipe::GetMsg() throw(std::runtime_error) {
	DWORD buf, cbBytesRead;
	BOOL fSuccess = ReadFile(_hPipe, &buf, sizeof(DWORD), &cbBytesRead, NULL);
	if (!fSuccess || cbBytesRead == 0) {
		throw std::runtime_error("Failed read data from pipe");
	}
	else return buf;
}

// Fabric for Existing Pipes
std::shared_ptr<ExistPipe> CreateExistPipe(const tchar* const pipeName) {
	return std::make_shared<ExistPipe>(pipeName);
}
