#include "../include/am.ipc.exist-pipe.hpp"

namespace ipc {
	// Constructor
	ExistPipe::ExistPipe(const tchar* const pipeName) noexcept(false) {
		// Create names for pipe and pipe events
		const uint nameSize = 256;
		tchar _pipeName[nameSize], _pipeEvReqName[nameSize], _pipeEvRespName[nameSize];
		ConvertNames(_pipeName, _pipeEvReqName, _pipeEvRespName, nameSize, pipeName);

		// Open existing pipe as File
		_hPipe = CreateFile(_pipeName,
			GENERIC_READ | GENERIC_WRITE, 0,
			NULL, OPEN_EXISTING, 0, NULL);
		// If opening pipe failed
		if (_hPipe == INVALID_HANDLE_VALUE) {
			throw std::runtime_error("Failed opening of existing pipe");
		}

		// Open existing pipe events
		try {
			OpenEv(_evRequest, _pipeEvReqName);
			OpenEv(_evResponse, _pipeEvRespName);
		}
		catch (std::runtime_error&) {
			// Rethrow if catch exepction
			throw;
		}
	}

	// Open existing pipe events and check errors
	void ExistPipe::OpenEv(HANDLE& evHandle, const tchar* const evName) noexcept(false) {
		// Open existing pipe event
		evHandle = CreateEvent(NULL, FALSE, FALSE, evName);
		// If pipe didn't exist before that moment
		// this mean that existing pipe was closed
		if (GetLastError() != ERROR_ALREADY_EXISTS || evHandle == NULL) {
			CloseHandle(evHandle);
			throw std::runtime_error("Failed opening of existing pipe event");
		}
	}

	// Read message from Pipe by client proccess
	DWORD ExistPipe::GetMsg() noexcept(false) {
		DWORD buf, cbBytesRead;
		BOOL fSuccess = ReadFile(_hPipe, &buf, sizeof(DWORD), &cbBytesRead, NULL);
		if (!fSuccess || cbBytesRead == 0) {
			throw std::runtime_error("Failed read data from pipe");
		}
		else return buf;
	}

	// Fabric for Existing Pipes
	std::shared_ptr<ExistPipe> CreateExistPipe(const tchar* const pipeName) noexcept {
		return std::shared_ptr<ExistPipe>(new ExistPipe(pipeName));
	}

}