#include "../include/am.auth.protocol.hpp"
#include <random>
#include <climits>

namespace auth {
	// Function gives random number in range [start, end]
	int GetRandNum(int start, int end) noexcept {
		// Entropy source
		std::random_device random_device;
		// Random number generator
		std::mt19937 generator(random_device());
		// Uniform distribution in range [start, end]
		std::uniform_int_distribution<> distribution(start, end);
		// Random number
		int x = distribution(generator);
		return x;
	}

	// Function that calculates checksum via CRC16 algorithm
	DWORD CRC16(uint8_t* addr, unsigned int length) noexcept {
		const uint32_t offset = 0x00000010;
		const uint32_t nand = 0xffffffff;
		register uint32_t sum = 0;
		while (length > 1) {
			sum += *addr++;
			length -= sizeof(uint8_t);
		}
		if (length > 0) sum += *(uint8_t*)addr;
		while (sum >> offset) {
			sum = (sum & nand) + (sum >> offset);
		}
		return static_cast<DWORD>(~sum);
	}
	
	// Simple authorization algorithm for server pipe process
	AuthStatus auth::AuthServer(ServerPipe& server) noexcept {
		AuthStatus stat = AuthStatus::Disconnected;
		try {
			// Generate random number
			DWORD someRandNum{ static_cast<DWORD>(GetRandNum(INT_MIN, INT_MAX)) };
			// Gets checksum of random number
			DWORD checksum{ CRC16(reinterpret_cast<uint8_t*>(&someRandNum), sizeof(someRandNum)) };
			// Sends random number to client 
			server.SendMsg(someRandNum);
			// Wait message from client and save it
			server.WaitIncomingMsg();
			DWORD verify = server.ReadMsg<DWORD>();
			// Verify checksum from client and checksum of pipe owner proccess
			if (verify == checksum) stat = AuthStatus::Connected;
			server.SendMsg(stat);
		}
		// If gets error in some algorithm step
		catch (...) {
			stat = AuthStatus::Disconnected;
		}
		return stat;
	}

	// Simple authorization algorithm for client pipe process
	AuthStatus AuthClient(ClientPipe& client) noexcept {
		AuthStatus connectStatus = AuthStatus::Disconnected;
		try {
			client.WaitIncomingMsg();
			DWORD response = client.ReadMsg<DWORD>();
			DWORD checksum = CRC16(reinterpret_cast<uint8_t*>(&response), sizeof(response));
			client.SendMsg(checksum);
			client.WaitIncomingMsg();
			connectStatus = client.ReadMsg<AuthStatus>();
		}
		// If gets error in some algorithm step
		catch (...) {
			connectStatus = AuthStatus::Disconnected;
		}
		return connectStatus;
	}
	
}
