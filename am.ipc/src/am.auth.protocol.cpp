#include "../include/am.auth.protocol.hpp"
#include <random>
#include <climits>

namespace auth {
	using ipc::ServerPipe;
	using ipc::ClientPipe;
	using ipc::MessageHolder;

	// Function gives random number in range [start, end]
	int GetRandNum(int start, int end) noexcept {
		// Entropy source
		std::random_device random_device;
		// Random number generator
		std::mt19937 generator(random_device());
		// Uniform distribution in range [start, end]
		std::uniform_int_distribution<> distribution(start, end);
		// Random number
		int x = distribution(generator);
		return x;
	}

	// Function that calculates checksum via CRC16 algorithm
	DWORD CRC16(uint8_t* addr, unsigned int length) noexcept {
		const uint32_t offset = 0x00000010;
		const uint32_t nand = 0xffffffff;
		register uint32_t sum = 0;
		while (length > 1) {
			sum += *addr++;
			length -= sizeof(uint8_t);
		}
		if (length > 0) sum += *(uint8_t*)addr;
		while (sum >> offset) {
			sum = (sum & nand) + (sum >> offset);
		}
		return static_cast<DWORD>(~sum);
	}
	
	// Simple authorization algorithm for server pipe process
	AuthStat AuthServer(ServerPipe& server) noexcept {
		AuthStat stat = AuthStat::Disconnected;
		try {
			MessageHolder buffer;
			// Generate random number
			auto someRandNum(static_cast<DWORD>(GetRandNum(INT_MIN, INT_MAX)));
			// Gets checksum of random number
			auto checksum(CRC16(reinterpret_cast<uint8_t*>(&someRandNum), sizeof(someRandNum)));
			buffer.Pack(someRandNum);
			// Sends random number to client 
			server.SendMsg(buffer);
			// Wait message from client and save it

			//server.WaitIncomingMsg();

			buffer = server.ReadMsg();
			// Verify checksum from client and checksum of pipe owner proccess
			if (buffer.Unpack<DWORD>() == checksum) stat = AuthStat::Connected;
			else stat = AuthStat::Disconnected;
			buffer.Pack(stat);
			server.SendMsg(buffer);
		}
		// If gets error in some algorithm step
		catch (...) {
			server._tracer.Trace(trace::TraceLevel::Error)
				<< TEXT("auth::AuthServer\t\tSome error occurs!\n") << std::flush;
			stat = AuthStat::Disconnected;
		}
		return stat;
	}

	// Simple authorization algorithm for client pipe process
	AuthStat AuthClient(ClientPipe& client) noexcept {
		AuthStat connectStatus = AuthStat::Disconnected;
		try {
			//client.WaitIncomingMsg();

			auto response(client.ReadMsg().Unpack<DWORD>());
			auto checksum = CRC16(reinterpret_cast<uint8_t*>(&response), sizeof(DWORD));
			MessageHolder buffer;
			buffer.Pack(checksum);
			client.SendMsg(buffer);

			//client.WaitIncomingMsg();

			buffer = client.ReadMsg();
			connectStatus = buffer.Unpack<AuthStat>();

			// Debug trace info
			client._tracer.Trace(trace::TraceLevel::Info)
				<< TEXT("auth::AuthClient\nServer response: ")
				<< response << TEXT("\nClient checksum: ")
				<< checksum << TEXT("\nAuthStatus: ")
				<< connectStatus << TEXT('\n');
		}
		// If gets error in some algorithm step
		catch (...) {
			client._tracer.Trace(trace::TraceLevel::Error)
				<< TEXT("auth::AuthClient\t\tSome error occurs!\n");
			connectStatus = AuthStat::Disconnected;
		}
		return connectStatus;
	}
	
}
