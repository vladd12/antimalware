#include "../include/am.auth.protocol.hpp"
#include <random>
#include <climits>

namespace auth {
	// Function gives random number in range [start, end]
	int GetRandNum(int start, int end) noexcept {
		// Entropy source
		std::random_device random_device;
		// Random number generator
		std::mt19937 generator(random_device());
		// Uniform distribution in range [start, end]
		std::uniform_int_distribution<> distribution(start, end);
		// Random number
		int x = distribution(generator);
		return x;
	}

	// Function that calculates checksum via CRC16 algorithm
	DWORD CRC16(uint8_t* addr, unsigned int length) noexcept {
		const uint32_t offset = 0x00000010;
		const uint32_t nand = 0xffffffff;
		register uint32_t sum = 0;
		while (length > 1) {
			sum += *addr++;
			length -= sizeof(uint8_t);
		}
		if (length > 0) sum += *(uint8_t*)addr;
		while (sum >> offset) {
			sum = (sum & nand) + (sum >> offset);
		}
		return static_cast<DWORD>(~sum);
	}

	// Simple authorization algorithm for server pipe process
	void AuthServer(ServerPipe& server, DWORD& request) noexcept {
		try {
			// Save request
			DWORD req = server.GetMsg();
			// Generate random number
			DWORD someRandNum = static_cast<DWORD>(GetRandNum(INT_MIN, INT_MAX));
			// Gets checksum of random number
			DWORD checksum = CRC16(reinterpret_cast<uint8_t*>(&someRandNum), sizeof(someRandNum));
			// Sends random number to client 
			server.SendMsg(someRandNum);
			// Wait message from client and save it
			server.WaitIncomingMsg();
			DWORD verify = server.GetMsg();
			// Verify checksum from client and checksum of pipe owner proccess
			if (verify == checksum) {
				server.SendMsg(static_cast<DWORD>(AuthStatus::Connected));
				request = req;
			}
			else {
				server.SendMsg(static_cast<DWORD>(AuthStatus::Disconnected));
				request = 0;
			}
		}
		// If gets error in some algorithm step
		catch (std::runtime_error&) {
			request = 0;
		}
	}

	// Simple authorization algorithm for client pipe process
	void AuthClient(ClientPipe& client, DWORD& conStatus) noexcept {
		try {
			client.WaitIncomingMsg();
			DWORD response = client.GetMsg();
			DWORD checksum = CRC16(reinterpret_cast<uint8_t*>(&response), sizeof(response));
			client.SendMsg(checksum);
			client.WaitIncomingMsg();
			conStatus = client.GetMsg();
		}
		// If gets error in some algorithm step
		catch (std::runtime_error&) {
			conStatus = static_cast<DWORD>(AuthStatus::Disconnected);
		}
	}

}
