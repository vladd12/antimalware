#include "../include/am.auth.protocol.hpp"
#include <random>
#include <climits>

namespace auth {
	using ipc::ServerPipe;
	using ipc::ClientPipe;

	// Function gives random number in range [start, end]
	int GetRandNum(int start, int end) noexcept {
		// Entropy source
		std::random_device random_device;
		// Random number generator
		std::mt19937 generator(random_device());
		// Uniform distribution in range [start, end]
		std::uniform_int_distribution<> distribution(start, end);
		// Random number
		int x = distribution(generator);
		return x;
	}

	// Function that calculates checksum via CRC16 algorithm
	DWORD CRC16(uint8_t* addr, unsigned int length) noexcept {
		const uint32_t offset = 0x00000010;
		const uint32_t nand = 0xffffffff;
		register uint32_t sum = 0;
		while (length > 1) {
			sum += *addr++;
			length -= sizeof(uint8_t);
		}
		if (length > 0) sum += *(uint8_t*)addr;
		while (sum >> offset) {
			sum = (sum & nand) + (sum >> offset);
		}
		return static_cast<DWORD>(~sum);
	}
	
	// Simple authorization algorithm for server pipe process
	AuthStatus AuthServer(ServerPipe& server) noexcept {
		AuthStatus stat = AuthStatus::Disconnected;
		try {
			// Generate random number
			auto someRandNum = static_cast<DWORD>(GetRandNum(INT_MIN, INT_MAX));
			// Gets checksum of random number
			auto checksum = CRC16(reinterpret_cast<uint8_t*>(&someRandNum), sizeof(someRandNum));
			// Sends random number to client 
			server.SendMsg(someRandNum);
			// Wait message from client and save it
			server.WaitIncomingMsg();
			auto verify = server.ReadMsg<DWORD>();
			// Verify checksum from client and checksum of pipe owner proccess
			if (verify == checksum) stat = AuthStatus::Connected;
			// Debug trace info
			server._tracer.Trace(trace::TraceLevel::Info)
				<< TEXT("auth::AuthServer\nServer checksum: ")
				<< checksum << TEXT("\nClient checksum: ")
				<< verify << TEXT("\nAuthStatus: ") << stat << TEXT('\n')
				<< std::flush;
			server.SendMsg(stat);
		}
		// If gets error in some algorithm step
		catch (...) {
			server._tracer.Trace(trace::TraceLevel::Error)
				<< TEXT("auth::AuthServer\t\tSome error occurs!\n") << std::flush;
			stat = AuthStatus::Disconnected;
		}
		return stat;
	}

	// Simple authorization algorithm for client pipe process
	AuthStatus AuthClient(ClientPipe& client) noexcept {
		AuthStatus connectStatus = AuthStatus::Disconnected;
		try {
			client.WaitIncomingMsg();
			auto response = client.ReadMsg<DWORD>();
			auto checksum = CRC16(reinterpret_cast<uint8_t*>(&response), sizeof(response));
			client.SendMsg(checksum);
			client.WaitIncomingMsg();
			connectStatus = client.ReadMsg<AuthStatus>();

			// Debug trace info
			client._tracer.Trace(trace::TraceLevel::Info)
				<< TEXT("auth::AuthClient\nServer response: ")
				<< response << TEXT("\nClient checksum: ")
				<< checksum << TEXT("\nAuthStatus: ") << stat << TEXT('\n');
		}
		// If gets error in some algorithm step
		catch (...) {
			client._tracer.Trace(trace::TraceLevel::Error)
				<< TEXT("auth::AuthClient\t\tSome error occurs!\n");
			connectStatus = AuthStatus::Disconnected;
		}
		return connectStatus;
	}
	
}
