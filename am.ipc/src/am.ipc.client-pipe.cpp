#include "../include/am.ipc.client-pipe.hpp"
#include <fstream>

namespace ipc {
	void DebugInfo(HANDLE&);

	// Constructor
	ClientPipe::ClientPipe(const tchar* const pipeName) noexcept(false) {
		// Create names for pipe and pipe events
		const uint nameSize = 256;
		tchar _pipeName[nameSize], _pipeEvReqName[nameSize], _pipeEvRespName[nameSize];
		ConvertNames(_pipeName, _pipeEvReqName, _pipeEvRespName, nameSize, pipeName);

		// Open existing pipe as File
		_hPipe = CreateFile(_pipeName,
			GENERIC_READ | GENERIC_WRITE, 0,
			NULL, OPEN_EXISTING, 0, NULL);
		// If opening pipe failed
		if (_hPipe == INVALID_HANDLE_VALUE) {

			// DEBUG
			std::wofstream out("E:\\Test.txt", std::ios::app);
			out << L"Failed opening of existing pipe.\n\n";
			out.close();

			throw std::runtime_error("Failed opening of existing pipe");
		}

		// DEBUG
		std::wofstream out("E:\\Test.txt", std::ios::app);
		out << L"ExistPipe: " << _pipeName << L"\n\n";
		out.close();
		//DebugInfo(_hPipe);

		// Open existing pipe events
		try {
			OpenEv(_evRequest, _pipeEvReqName);
			OpenEv(_evResponse, _pipeEvRespName);
		}
		catch (std::runtime_error&) {
			// Rethrow if catch exepction
			throw;
		}
	}

	// Open existing pipe events and check errors
	void ClientPipe::OpenEv(HANDLE& evHandle, const tchar* const evName) noexcept(false) {
		// Open existing pipe event
		evHandle = OpenEvent(EVENT_ALL_ACCESS, FALSE, evName);
		// If pipe didn't exist before that moment
		// this mean that existing pipe was closed
		DWORD errState = GetLastError();

		// DEBUG
		std::wofstream out("E:\\Test.txt", std::ios::app);
		out << L"In ExistPipe::OpenEv func: " << evName << L'\n'
			<< L"evHandle: " << evHandle << L'\n'
			<< L"GetLastError: " << errState << L"\n\n";
		out.close();

		if (evHandle == NULL) {
			CloseHandle(evHandle);
			throw std::runtime_error("Failed opening of existing pipe event");
		}
	}

	// Send message (request) from another process/instance of pipe
	void ClientPipe::SendMsg(DWORD msg) noexcept(false) {
		// Using BasePipe::SendMsgBase(DWORD&)
		try {
			SendMsgBase(msg);
		}
		// Rethrow exception
		catch (std::runtime_error&) {
			throw;
		}
		// Activate event that informs that request has been sent 
		SetEvent(_evRequest);
	}

	// Read message from Pipe by client process
	DWORD ClientPipe::GetMsg() noexcept(false) {
		DWORD buf, cbBytesRead;
		BOOL fSuccess = ReadFile(_hPipe, &buf, sizeof(DWORD), &cbBytesRead, NULL);
		if (!fSuccess || cbBytesRead == 0) {
			throw std::runtime_error("Failed read data from pipe");
		}
		else {
			// Response message has been read
			ResetEvent(_evResponse);
			return buf;
		}
	}

	// Is are incoming message for another process/instance of pipe?
	bool ClientPipe::IsIncomingMsg() noexcept(false) {
		DWORD dwWait = WaitForSingleObject(_evResponse, 1);
		if (dwWait == WAIT_FAILED) {
			throw std::runtime_error("Failed waiting for pipe response event");
		}
		else if (dwWait == WAIT_TIMEOUT) {
			return false;
		}
		else return true;
	}

	// Another process/instance of pipe waits until a message is sent to him
	void ClientPipe::WaitIncomingMsg() noexcept(false) {
		DWORD dwWait = WaitForSingleObject(_evResponse, INFINITE);
		if (dwWait == WAIT_OBJECT_0) return;
		else {
			std::runtime_error("Failed waiting for pipe response event");
		}
	}

	// Fabric for Existing Pipes
	std::shared_ptr<ClientPipe> CreateClientPipe(const tchar* const pipeName) noexcept {
		return std::shared_ptr<ClientPipe>(new ClientPipe(pipeName));
	}

	// DEBUG INFO ABOUT PIPE
	void DebugInfo(HANDLE& hPipe) {
		DWORD state, curInstances, maxCollCount, dataTimeout;
		TCHAR username[MAX_PATH];
		GetNamedPipeHandleState(hPipe, &state, &curInstances,
			&maxCollCount, &dataTimeout, username, MAX_PATH);
		// DEBUG
		std::wofstream out("E:\\Test.txt", std::ios::app);
		out << L"Named Pipe State:\nState: " << state << L"\nCurrent Instances: "
			<< curInstances << L"\nMax Collection Count: " << maxCollCount
			<< L"\nCollect Data Timeout: " << dataTimeout << L"\nUsername: "
			<< username << L"\n\n";
		out.close();
	}

}
