#include "../include/am.ipc.client-pipe.hpp"

namespace ipc {
	// Default constructor
	ClientPipe::ClientPipe() noexcept : BasePipe() { }

	// Constructor with params
	ClientPipe::ClientPipe(const std::string& _pipeName)
	  noexcept(false): pipeName(_pipeName) {
		if (!CreatePipe(_pipeName)) {
			throw std::runtime_error("Failed pipe opening");
		}
		if (!SetPipeState()) {
			throw std::runtime_error("Failed pipe state changing");
		}
	}

	// Copying constructor
	ClientPipe::ClientPipe(const ClientPipe& rhs) noexcept {
		hPipe = rhs.hPipe;
		pipeName = rhs.pipeName;
	}

	// Overloading operator "="
	ClientPipe& ClientPipe::operator=(const ClientPipe& rhs) noexcept {
		hPipe = rhs.hPipe;
		pipeName = rhs.pipeName;
		return *this;
	}

	// Opening and connecting to existing pipe
	bool ClientPipe::CreatePipe(const std::string& pipeName) noexcept {
		std::string realName("\\\\.\\pipe\\" + pipeName);
		hPipe = CreateFileA(realName.c_str(), GENERIC_READ | GENERIC_WRITE,
			0, NULL, OPEN_EXISTING, 0, NULL);
		if (hPipe == INVALID_HANDLE_VALUE) {
			errCode = GetLastError();
			return false;
		}
		else return true;
	}

	// Change to message-read mode
	bool ClientPipe::SetPipeState() noexcept {
		DWORD dwMode = PIPE_READMODE_MESSAGE;
		if (!SetNamedPipeHandleState(hPipe, &dwMode, NULL, NULL)) {
			errCode = GetLastError();
			return false;
		}
		else return true;
	}

	// Close and open current pipe
	bool ClientPipe::Reopen() noexcept {
		Close();
		return CreatePipe(pipeName);
	}


}
